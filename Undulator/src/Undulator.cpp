/*----- PROTECTED REGION ID(Undulator.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        Undulator.cpp
//
// description : C++ source for the Undulator and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Undulator are implemented in this file.
//
// project :     .
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL:  $
//
// CVS only:
// $Source:  $
// $Log:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <Undulator.h>
#include <UndulatorClass.h>
#include <cmath>

#include "insertion/Communicator.h"
#include "insertion/PollerThread.h"
#include "insertion/StateProcessor.h"
#include "insertion/FlagsProcessor.h"
#include "correction/CorrectionCoils.h"


#define VECTOR_UNIT_TO_INDIVIDUAL 1.414213562 //!< Converts vector speed/acceleration into axis speed/acceleration for phase (2 axes in movement)

/*----- PROTECTED REGION END -----*/


/**
 *	Undulator class description:
 *	Device server for control of  EPU61 insertion device with Galil DMC 4080 controllers.
 *	
 */

//================================================================
//
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name        |  Method name
//----------------------------------------------------------------
//  State               |  Inherited (no method)
//  Status              |  Inherited (no method)
//  StopGap             |  stop_gap
//  ToggleStopAll       |  toggle_stop_all
//  StopPhase           |  stop_phase
//  CalibrateGap        |  calibrate_gap
//  CalibratePhase      |  calibrate_phase
//  LoadCorrectionData  |  load_correction_data
//  ResetDrive          |  reset_drive
//================================================================

namespace Undulator_ns
{
	/*----- PROTECTED REGION ID(Undulator::namespace_starting) ENABLED START -----*/





	/*----- PROTECTED REGION END -----*/	//	Undulator::namespace_starting



//--------------------------------------------------------
/**
 *	Method      : Undulator::Undulator()
 *	Description : Constructors for a Tango device
 *	              implementing the class Undulator
 */
//--------------------------------------------------------
Undulator::Undulator(Tango::DeviceClass *cl, string &s)
 	: Tango::Device_4Impl(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(Undulator::constructor_1) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Undulator::constructor_1
}
//--------------------------------------------------------
Undulator::Undulator(Tango::DeviceClass *cl, const char *s)
 	: Tango::Device_4Impl(cl, s)
{
	/*----- PROTECTED REGION ID(Undulator::constructor_2) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Undulator::constructor_2
}
//--------------------------------------------------------
Undulator::Undulator(Tango::DeviceClass *cl, const char *s, const char *d)
 	: Tango::Device_4Impl(cl, s, d)
{
	/*----- PROTECTED REGION ID(Undulator::constructor_3) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Undulator::constructor_3
}


//--------------------------------------------------------
/**
 *	Method      : Undulator::delete_device()()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Undulator::delete_device()
{
	/*----- PROTECTED REGION ID(Undulator::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	if (poller)
	{
		poller->abort();
		poller->join(0);
		poller = 0;
	}

	if (stateProc)
	{
		delete stateProc;
		stateProc=0;
	}

	if (flagProc)
	{
		delete flagProc;
		flagProc=0;
	}

	if (correctionCoils)
	{
		delete correctionCoils;
		correctionCoils = 0;
	}

	if (comm) delete comm;
    if (phaseAxesGroup) delete phaseAxesGroup;
    if (gapAxesGroup) delete gapAxesGroup;

	/*----- PROTECTED REGION END -----*/	//	Undulator::delete_device
	
}


//--------------------------------------------------------
/**
 *	Method      : Undulator::init_device()
 *	Description : //	will be called at device initialization.
 */
//--------------------------------------------------------
void Undulator::init_device()
{
	DEBUG_STREAM << "Undulator::init_device() create device " << device_name << endl;

	/*----- PROTECTED REGION ID(Undulator::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call

	/*----- PROTECTED REGION END -----*/	//	Undulator::init_device_before
	
	//	Get the device properties (if any) from database
	get_device_property();
	
	
	/*----- PROTECTED REGION ID(Undulator::init_device) ENABLED START -----*/

	// Initialize pointers to null
	poller = 0;
	stateProc = 0;
	correctionCoils = 0;
	phaseAxesGroup = gapAxesGroup = 0;
	comm = 0;

	minGap = 0;
	maxGap = 0;
	maxOpPhase = 0;
	desiredGap = 0;
	desiredOffset = 0;
	desiredCenter = 0;
	desiredTaper = 0;
    
    cycleTime = 0.0f;

	engineeringLock = false;

	try
	{
	    // Create groups.
	    phaseAxesGroup = new Tango::Group("");
	    gapAxesGroup = new Tango::Group("");

	    if(gapAxes.size() != phaseAxes.size())
	        Tango::Except::throw_exception("Number of gap and phase axes doesn't match.",
	                    "Number of proxys for gap and phase in properties is not the same.","init_device()", Tango::ERR);

	    for(uint i = 0; i < gapAxes.size(); i++)
	    {
	        phaseAxesGroup->add(phaseAxes[i]);
	        gapAxesGroup->add(gapAxes[i]);
	    }

	    std::vector<std::string> communicatorParams;
		communicatorParams.push_back(controlBoxGapProxy);
		communicatorParams.push_back(controlBoxPhaseProxy);
		comm = Communicator::create_communicator(communicatorParams);

	    // Read counts to micrometer ratio.
	    Tango::DbData deviceProperty;
	    string propertyName = "AxisPositionRatio";

	    // Read from first gap axis since all should be the same.
	    Tango::DeviceProxy(gapAxes[0]).get_property(propertyName , deviceProperty);
	    deviceProperty[0] >> positionRatioGap;

	    // Same for phase axis.
	    Tango::DeviceProxy(phaseAxes[0]).get_property(propertyName , deviceProperty);
	    deviceProperty[0] >> positionRatioPhase;

	    // Get gap & phase offsets
	    get_offsets_gap();
	    get_offsets_phase();

	    // Set tango state to DISABLE, temporary startup state
	    // State will be updated to standby or disabled as soon as the first state processor executes
	    this->set_state(Tango::DISABLE);

	    // Start thread for state and position updates.
	    poller = new PollerThread(*this, pollerCycleDelay,controlBoxGapProxy,controlBoxPhaseProxy);

	    // Create processors
	    correctionCoils = new CorrectionCoils(*this, powerSupplyProxy, powerSupplyAttributeNames);
	    coilCorrectionEnabled = false;

	    flagProc = new FlagsProcessor(*this);
	    stateProc = new StateProcessor(*this, gapAxes, phaseAxes, gearedAxes);


	    poller->register_processor(coilProcMultiplier, correctionCoils);
	    poller->register_processor(flagsProcMultiplier, flagProc);
	    poller->register_processor(stateProcMultiplier,stateProc);
    
        // Update the encoder offsets on the Galil
        comm->update_gap_encoder_offsets(offsetsGapVector,(1/positionRatioGap));
        comm->update_phase_encoder_offsets(offsetsPhaseVector,(1/positionRatioPhase));
        
        cout << "Starting poller..." << endl;
	    poller->go();
	}
	catch(Tango::DevFailed& err)
	{
	    this->set_state(Tango::FAULT);
	    stringstream msgfmt;
	    msgfmt << "Tango exception in initialization." << endl
	            << "Reason: " << err.errors[0].reason << endl
	            << "Description: " << err.errors[0].desc;
	    ERROR_STREAM << msgfmt.str();
	    cerr << msgfmt.str() << endl;
	}
	catch(std::exception& err)
	{
	    this->set_state(Tango::FAULT);

	    stringstream msgfmt;
	    msgfmt << "std::exception caught:" << err.what();
	    ERROR_STREAM << msgfmt.str();
	    cerr << msgfmt.str() << endl;
	} catch (omni_thread_invalid &e)
	{
		this->set_state(Tango::FAULT);

		string msg = "omni_thread_invalid exception, omnithreads call failed with invalid arguments!";
		ERROR_STREAM << msg;
		cerr << msg << endl;
	}
	catch(...)
	{
	    this->set_state(Tango::FAULT);

	    string msg = "Unknown exception occurred in initialization.";
	    ERROR_STREAM << msg;
	    cerr << msg << endl;
	}

	// Try to load the interpolation data table from the provided DataFile property
    try
    {
        if(this->state() != Tango::FAULT)
        {
        	correctionCoils->load_correction_data(dataFile.c_str());

        	// Enable compensation after data is loaded
        	correctionCoils->set_compensate(true);
        }
    }
    catch (...)
    {
        WARN_STREAM << "Couldn't load correction coil data file from property." << endl;
    }


	/*----- PROTECTED REGION END -----*/	//	Undulator::init_device
}



//--------------------------------------------------------
/**
 *	Method      : Undulator::get_device_property()
 *	Description : //	Add your own code to initialize
 */
//--------------------------------------------------------
void Undulator::get_device_property()
{
	/*----- PROTECTED REGION ID(Undulator::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	Undulator::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("ControlBoxGapProxy"));
	dev_prop.push_back(Tango::DbDatum("GapAxes"));
	dev_prop.push_back(Tango::DbDatum("PhaseAxes"));
	dev_prop.push_back(Tango::DbDatum("ControlBoxPhaseProxy"));
	dev_prop.push_back(Tango::DbDatum("GearedAxes"));
	dev_prop.push_back(Tango::DbDatum("DataFile"));
	dev_prop.push_back(Tango::DbDatum("PowerSupplyProxy"));
	dev_prop.push_back(Tango::DbDatum("PowerSupplyAttributeNames"));
	dev_prop.push_back(Tango::DbDatum("PollerCycleDelay"));
	dev_prop.push_back(Tango::DbDatum("StateProcMultiplier"));
	dev_prop.push_back(Tango::DbDatum("CoilProcMultiplier"));
	dev_prop.push_back(Tango::DbDatum("FlagsProcMultiplier"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on UndulatorClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		UndulatorClass	*ds_class =
			(static_cast<UndulatorClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize ControlBoxGapProxy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  controlBoxGapProxy;
		else {
			//	Try to initialize ControlBoxGapProxy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  controlBoxGapProxy;
		}
		//	And try to extract ControlBoxGapProxy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  controlBoxGapProxy;

		//	Try to initialize GapAxes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gapAxes;
		else {
			//	Try to initialize GapAxes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gapAxes;
		}
		//	And try to extract GapAxes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gapAxes;

		//	Try to initialize PhaseAxes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  phaseAxes;
		else {
			//	Try to initialize PhaseAxes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  phaseAxes;
		}
		//	And try to extract PhaseAxes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  phaseAxes;

		//	Try to initialize ControlBoxPhaseProxy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  controlBoxPhaseProxy;
		else {
			//	Try to initialize ControlBoxPhaseProxy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  controlBoxPhaseProxy;
		}
		//	And try to extract ControlBoxPhaseProxy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  controlBoxPhaseProxy;

		//	Try to initialize GearedAxes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gearedAxes;
		else {
			//	Try to initialize GearedAxes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gearedAxes;
		}
		//	And try to extract GearedAxes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gearedAxes;

		//	Try to initialize DataFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dataFile;
		else {
			//	Try to initialize DataFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dataFile;
		}
		//	And try to extract DataFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dataFile;

		//	Try to initialize PowerSupplyProxy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  powerSupplyProxy;
		else {
			//	Try to initialize PowerSupplyProxy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  powerSupplyProxy;
		}
		//	And try to extract PowerSupplyProxy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  powerSupplyProxy;

		//	Try to initialize PowerSupplyAttributeNames from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  powerSupplyAttributeNames;
		else {
			//	Try to initialize PowerSupplyAttributeNames from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  powerSupplyAttributeNames;
		}
		//	And try to extract PowerSupplyAttributeNames value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  powerSupplyAttributeNames;

		//	Try to initialize PollerCycleDelay from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pollerCycleDelay;
		else {
			//	Try to initialize PollerCycleDelay from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pollerCycleDelay;
		}
		//	And try to extract PollerCycleDelay value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pollerCycleDelay;

		//	Try to initialize StateProcMultiplier from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  stateProcMultiplier;
		else {
			//	Try to initialize StateProcMultiplier from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  stateProcMultiplier;
		}
		//	And try to extract StateProcMultiplier value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stateProcMultiplier;

		//	Try to initialize CoilProcMultiplier from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  coilProcMultiplier;
		else {
			//	Try to initialize CoilProcMultiplier from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  coilProcMultiplier;
		}
		//	And try to extract CoilProcMultiplier value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  coilProcMultiplier;

		//	Try to initialize FlagsProcMultiplier from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  flagsProcMultiplier;
		else {
			//	Try to initialize FlagsProcMultiplier from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  flagsProcMultiplier;
		}
		//	And try to extract FlagsProcMultiplier value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  flagsProcMultiplier;


	}
	/*----- PROTECTED REGION ID(Undulator::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	Undulator::get_device_property_after

}

//--------------------------------------------------------
/**
 *	Method      : Undulator::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void Undulator::always_executed_hook()
{
	INFO_STREAM << "Undulator::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::always_executed_hook) ENABLED START -----*/


	/*----- PROTECTED REGION END -----*/	//	Undulator::always_executed_hook
}



//--------------------------------------------------------
/**
 *	Method      : Undulator::read_attr_hardware()
 *	Description : Hardware acquisition for attributes.
 */
//--------------------------------------------------------
void Undulator::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "Undulator::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_attr_hardware) ENABLED START -----*/



	/*----- PROTECTED REGION END -----*/	//	Undulator::read_attr_hardware

}


//--------------------------------------------------------
/**
 *	Read Gap attribute
 *	Description: Read-back and set-point for current gap. 
 *	             Writing to this attribute commences movement for the gap, 
 *	             using the current operator center offset and taper.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Gap(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Gap(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Gap) ENABLED START -----*/

	// Read max phase offset value from properties.
    Tango::AttributeConfig confGap;
    attr.get_properties(confGap);

    // Convert string to double.
    double max = atof(confGap.max_value);
    double min = atof(confGap.min_value);

    omni_mutex_lock guard(deviceLock);
    attr.set_value(&idPosition.gap);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Gap
}

//--------------------------------------------------------
/**
 *	Write Gap attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Gap(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Gap(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Gap) ENABLED START -----*/

	desiredGap = w_val;
    start_gap();

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Gap
}

//--------------------------------------------------------
/**
 *	Read EngineeringLock attribute
 *	Description: Setting this attribute to TRUE disables operator composite movements. 
 *	             Engineering movements to be done directly on the ControlBox axis devices.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringLock(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringLock(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringLock) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&engineeringLock);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringLock
}

//--------------------------------------------------------
/**
 *	Write EngineeringLock attribute values to hardware.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringLock(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringLock(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringLock) ENABLED START -----*/

	engineeringLock = static_cast<bool>(w_val);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringLock
}

//--------------------------------------------------------
/**
 *	Read GapAcceleration attribute
 *	Description: Gap movement average acceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapAcceleration) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&gapAcc);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapAcceleration
}

//--------------------------------------------------------
/**
 *	Write GapAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_GapAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_GapAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_GapAcceleration) ENABLED START -----*/

	gapAcc = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_GapAcceleration
}

//--------------------------------------------------------
/**
 *	Read GapSpeed attribute
 *	Description: Final profile velocity in um/s for gap movements.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapSpeed) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&gapSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapSpeed
}

//--------------------------------------------------------
/**
 *	Write GapSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_GapSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_GapSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_GapSpeed) ENABLED START -----*/

    gapSpeed = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_GapSpeed
}

//--------------------------------------------------------
/**
 *	Read PhaseAcceleration attribute
 *	Description: Phase movement average acceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseAcceleration) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&phaseAcc);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Write PhaseAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_PhaseAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_PhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_PhaseAcceleration) ENABLED START -----*/

	phaseAcc = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_PhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Read PhaseMode attribute
 *	Description: Read-back and set-point for desired phase mode. 
 *	             Will be used next time Phase is written.
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseMode(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseMode) ENABLED START -----*/

	attr.set_value(&idPosition.phaseMode);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseMode
}

//--------------------------------------------------------
/**
 *	Write PhaseMode attribute values to hardware.
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_PhaseMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_PhaseMode(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevShort	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_PhaseMode) ENABLED START -----*/

	desiredPhaseMode = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_PhaseMode
}

//--------------------------------------------------------
/**
 *	Read Phase attribute
 *	Description: Read-back and set-point for phase offset.
 *	             When this attribute is written new phase movement commences 
 *	             using phase mode specified in PhaseMode attribute.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Phase(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Phase(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Phase) ENABLED START -----*/

	// Read max phase offset value from properties.
	Tango::AttributeConfig confPhase;
	attr.get_properties(confPhase);
	// Convert string to double.
	double max = atof(confPhase.max_value);
	// If new maximum set, update it and recalculate new limits.
	if(max != maxOpPhase)
	{
	    maxOpPhase = max;
	}

	omni_mutex_lock guard(deviceLock);
	attr.set_value(&idPosition.phaseOffset);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Phase
}

//--------------------------------------------------------
/**
 *	Write Phase attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Phase(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Phase(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Phase) ENABLED START -----*/
	
	desiredOffset = w_val;
    start_phase();


	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Phase
}

//--------------------------------------------------------
/**
 *	Read PhaseSpeed attribute
 *	Description: Final profile velocity in um/s for phase (sub-girders) movement.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseSpeed) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&phaseSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseSpeed
}

//--------------------------------------------------------
/**
 *	Write PhaseSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_PhaseSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_PhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_PhaseSpeed) ENABLED START -----*/

	phaseSpeed = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_PhaseSpeed
}

//--------------------------------------------------------
/**
 *	Read TaperAcceleration attribute
 *	Description: Taper movement average acceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_TaperAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_TaperAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_TaperAcceleration) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&taperAcc);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_TaperAcceleration
}

//--------------------------------------------------------
/**
 *	Write TaperAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_TaperAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_TaperAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_TaperAcceleration) ENABLED START -----*/

	taperAcc = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_TaperAcceleration
}

//--------------------------------------------------------
/**
 *	Read Taper attribute
 *	Description: Read-back and set-point value for the current taper. 
 *	             Will be applied next time the GapSetpoint attribute is modified.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Taper(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Taper(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Taper) ENABLED START -----*/

	omni_mutex_lock guard(deviceLock);
	attr.set_value(&idPosition.taper);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Taper
}

//--------------------------------------------------------
/**
 *	Write Taper attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Taper(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Taper(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Taper) ENABLED START -----*/

	desiredTaper = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Taper
}

//--------------------------------------------------------
/**
 *	Read Offset attribute
 *	Description: Read-back and set-point value for the current vertical offset. 
 *	             Will be applied next time the Gap attribute is modified.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Offset(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Offset(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Offset) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&idPosition.center);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Offset
}

//--------------------------------------------------------
/**
 *	Write Offset attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Offset(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Offset(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Offset) ENABLED START -----*/

	desiredCenter = w_val;


	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Offset
}

//--------------------------------------------------------
/**
 *	Read TaperSpeed attribute
 *	Description: Final profile velocity in um/s for taper movements.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_TaperSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_TaperSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_TaperSpeed) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&taperSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_TaperSpeed
}

//--------------------------------------------------------
/**
 *	Write TaperSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_TaperSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_TaperSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_TaperSpeed) ENABLED START -----*/

	taperSpeed = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_TaperSpeed
}

//--------------------------------------------------------
/**
 *	Read StopAll attribute
 *	Description: Indicates that the undulator is in StopAll state inhibiting all motion.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_StopAll(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_StopAll(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_StopAll) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&idStatus.stopAll);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_StopAll
}
//--------------------------------------------------------
/**
 *	Read GapMoving attribute
 *	Description: Indicates that gap movement is in progress. 
 *	             Used to distinguish whether gap, phase or both are moving.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapMoving(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapMoving(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapMoving) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&idStatus.gapMoving);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapMoving
}
//--------------------------------------------------------
/**
 *	Read PhaseMoving attribute
 *	Description: Indicates that phase movement is in progress. 
 *	             Used to distinguish whether gap, phase or both are moving.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseMoving(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseMoving(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseMoving) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&idStatus.phaseMoving);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseMoving
}
//--------------------------------------------------------
/**
 *	Read EngineeringGapSpeed attribute
 *	Description: Final profile velocity in um/s for gap axes engineering movement.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringGapSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringGapSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringGapSpeed) ENABLED START -----*/

	// Get values.
	Tango::GroupAttrReplyList replyList = gapAxesGroup->read_attribute("velocity", false);

	// Check if read failed.
    if(replyList.has_failed())
    {
	    ERROR_STREAM << "Error reading engineering gap speed." << endl;
	    attr.set_quality(Tango::ATTR_INVALID);
    }
    else
    {
        double tempSpeed;

        // Extract first velocity.
        replyList[0] >> engineeringGapAxesSpeed;

        for(uint i = 1; i < replyList.size(); i++)
        {
            // Extract others and compare. If all are the same show speed otherwise show zero.
            replyList[i] >> tempSpeed;
            if(engineeringGapAxesSpeed != tempSpeed)
            {
                engineeringGapAxesSpeed = 0;
                break;
            }
        }
        attr.set_quality(Tango::ATTR_VALID);
    }
    //  Set the attribute value
	attr.set_value(&engineeringGapAxesSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringGapSpeed
}

//--------------------------------------------------------
/**
 *	Write EngineeringGapSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringGapSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringGapSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringGapSpeed) ENABLED START -----*/

	Tango::DeviceAttribute devattr("velocity", w_val);

	// Write attributes.
    gapAxesGroup->write_attribute(devattr, false);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringGapSpeed
}

//--------------------------------------------------------
/**
 *	Read EngineeringPhaseSpeed attribute
 *	Description: Final profile velocity in um/s for phase axes engineering movement.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringPhaseSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringPhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringPhaseSpeed) ENABLED START -----*/

    // Get values.
    Tango::GroupAttrReplyList replyList = phaseAxesGroup->read_attribute("velocity", false);

    // Check if read failed.
    if(replyList.has_failed())
    {
        ERROR_STREAM << "Error reading engineering phase speed." << endl;
        attr.set_quality(Tango::ATTR_INVALID);
    }
    else
    {
        double tempSpeed;

        // Extract first velocity.
        replyList[0] >> engineeringPhaseAxesSpeed;

        for(uint i = 1; i < replyList.size(); i++)
        {
            // Extract others and compare. If all are the same show speed otherwise show zero.
            replyList[i] >> tempSpeed;
            if(engineeringPhaseAxesSpeed != tempSpeed)
            {
                engineeringPhaseAxesSpeed = 0;
                break;
            }
        }
        attr.set_quality(Tango::ATTR_VALID);
    }
    //  Set the attribute value
	attr.set_value(&engineeringPhaseAxesSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringPhaseSpeed
}

//--------------------------------------------------------
/**
 *	Write EngineeringPhaseSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringPhaseSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringPhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringPhaseSpeed) ENABLED START -----*/

    Tango::DeviceAttribute devattr("velocity", w_val);

    // Write attributes.
    phaseAxesGroup->write_attribute(devattr);


	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringPhaseSpeed
}

//--------------------------------------------------------
/**
 *	Read EngineeringGapAcceleration attribute
 *	Description: Gap axes engineering movement average acceleration/deceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringGapAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringGapAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringGapAcceleration) ENABLED START -----*/

    vector<string> attrNames;
    attrNames.push_back("acceleration");
    attrNames.push_back("deceleration");
    Tango::GroupAttrReplyList replyList = gapAxesGroup->read_attributes(attrNames, false);

    // Check if read failed.
    if(replyList.has_failed())
    {
        ERROR_STREAM << "Error reading engineering gap acceleration." << endl;
        attr.set_quality(Tango::ATTR_INVALID);
    }
    else
    {
        replyList[0] >> engineeringGapAxesAcceleration; // Get first value.

        double tempAcc;

        // Go through all values and if all are the same set it to attribute otherwise set to 0.
        for(uint i = 1; i < replyList.size(); i++)
        {
            replyList[i] >> tempAcc;
            if(engineeringGapAxesAcceleration != tempAcc)
            {
                engineeringGapAxesAcceleration = 0;
                break;
            }
        }
        attr.set_quality(Tango::ATTR_VALID);
    }
    //  Set the attribute value
	attr.set_value(&engineeringGapAxesAcceleration);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringGapAcceleration
}

//--------------------------------------------------------
/**
 *	Write EngineeringGapAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringGapAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringGapAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringGapAcceleration) ENABLED START -----*/

	Tango::DeviceAttribute devattr("acceleration", w_val);

    // Write acceleration attributes.
    gapAxesGroup->write_attribute(devattr);

    // Write deceleration attributes.
    devattr.set_name("deceleration"); // Set the name of attribute.
    gapAxesGroup->write_attribute(devattr);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringGapAcceleration
}

//--------------------------------------------------------
/**
 *	Read EngineeringPhaseAcceleration attribute
 *	Description: Phase axes engineering movement average acceleration/deceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringPhaseAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringPhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringPhaseAcceleration) ENABLED START -----*/

	vector<string> attrNames;
    attrNames.push_back("acceleration");
    attrNames.push_back("deceleration");
    Tango::GroupAttrReplyList replyList = phaseAxesGroup->read_attributes(attrNames, false);

    // Check if read failed.
    if(replyList.has_failed())
    {
        ERROR_STREAM << "Error reading engineering phase acceleration." << endl;
        attr.set_quality(Tango::ATTR_INVALID);
    }
    else
    {
        replyList[0] >> engineeringPhaseAxesAcceleration; // Get first.
        double tempAcc;

        // Go through all values and if all are the same set it to attribute otherwise set to 0.
        for(uint i = 1; i < replyList.size(); i++)
        {
            replyList[i] >> tempAcc;
            if(engineeringPhaseAxesAcceleration != tempAcc)
            {
                engineeringPhaseAxesAcceleration = 0;
                break;
            }
        }
        attr.set_quality(Tango::ATTR_VALID);
    }
    //  Set the attribute value
    attr.set_value(&engineeringPhaseAxesAcceleration);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringPhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Write EngineeringPhaseAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringPhaseAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringPhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringPhaseAcceleration) ENABLED START -----*/

    Tango::DeviceAttribute devattr("acceleration", w_val);

    // Write acceleration attributes.
    phaseAxesGroup->write_attribute(devattr);

    // Write deceleration attributes.
    devattr.set_name("deceleration"); // Set the name of attribute.
    phaseAxesGroup->write_attribute(devattr);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringPhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Read Interlock attribute
 *	Description: Indicates that interlock is in effect.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Interlock(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Interlock(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Interlock) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&idStatus.interlock);
	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Interlock
}
//--------------------------------------------------------
/**
 *	Read CorrectionEnabled attribute
 *	Description: Enables correction.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_CorrectionEnabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_CorrectionEnabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_CorrectionEnabled) ENABLED START -----*/

	coilCorrectionEnabled = correctionCoils->is_compensating();
	//	Set the attribute value
	attr.set_value(&coilCorrectionEnabled);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_CorrectionEnabled
}

//--------------------------------------------------------
/**
 *	Write CorrectionEnabled attribute values to hardware.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_CorrectionEnabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_CorrectionEnabled(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_CorrectionEnabled) ENABLED START -----*/

	correctionCoils->set_compensate(w_val);
	coilCorrectionEnabled = correctionCoils->is_compensating();
	
	/*----- PROTECTED REGION END -----*/	//	Undulator::write_CorrectionEnabled
}

//--------------------------------------------------------
/**
 *	Read AxesFlags attribute
 *	Description: Represents bit-encoded axis flags
 *	             
 *	             Least significant byte, bits 0..7 represent communication error status for motors 1 to 8 respectively
 *	             More significant byte, bits 8..15 represent encoder error status for motors 1 to 8 respectively
 *	             More significant byte, bits 15..23 represent drive error status for motors 1 to 8 respectively
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_AxesFlags(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_AxesFlags(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_AxesFlags) ENABLED START -----*/

	//	Set the attribute value
    omni_mutex_lock guard(deviceLock);
	attr.set_value(&idStatus.axesFlags);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_AxesFlags
}
//--------------------------------------------------------
/**
 *	Read CycleTime attribute
 *	Description: Time between poller cycles, in milliseconds
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_CycleTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_CycleTime(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_CycleTime) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&cycleTime);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_CycleTime
}

//--------------------------------------------------------
/**
 *	Method      : Undulator::UndulatorClass::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *	              for specified device.
 */
//--------------------------------------------------------
void Undulator::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Undulator::Class::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	Undulator::Class::add_dynamic_attributes

}



//========================================================
//	Command execution methods
//========================================================

//--------------------------------------------------------
/**
 *	Execute the StopGap command:
 *	Description: Stops gap movement.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::stop_gap()
{
	DEBUG_STREAM << "Undulator::StopGap()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::stop_gap) ENABLED START -----*/

	//	Add your own code

	// Sends command to stop gap motors.
	comm->stop_gap();

	/*----- PROTECTED REGION END -----*/	//	Undulator::stop_gap

}

//--------------------------------------------------------
/**
 *	Execute the ToggleStopAll command:
 *	Description: Emergency stop all command. 
 *	             If called with the parameter set to TRUE, aborts all motion 
 *	             and inhibits all further requests for motion until the command 
 *	             is invoked again with the parameter set to FALSE.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::toggle_stop_all(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "Undulator::ToggleStopAll()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::toggle_stop_all) ENABLED START -----*/
	// Set or reset stop all
    comm->toggle_stop_all(argin);
	/*----- PROTECTED REGION END -----*/	//	Undulator::toggle_stop_all

}

//--------------------------------------------------------
/**
 *	Execute the StopPhase command:
 *	Description: Stops phase movement.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::stop_phase()
{
	DEBUG_STREAM << "Undulator::StopPhase()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::stop_phase) ENABLED START -----*/

	// Sends command to stop gap motors.
	comm->stop_phase();

	/*----- PROTECTED REGION END -----*/	//	Undulator::stop_phase

}

//--------------------------------------------------------
/**
 *	Execute the CalibrateGap command:
 *	Description: Calculates gap axes offsets using given gap and center and reading positions from encoders.
 *
 *	@param argin Current gap and center.
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::calibrate_gap(const Tango::DevVarDoubleArray *argin)
{
	DEBUG_STREAM << "Undulator::CalibrateGap()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::calibrate_gap) ENABLED START -----*/

	// Create a vector to fill with aux encoder positions.
    vector<double> encoderPos;

    comm->get_gap_linear_encoder_pos(encoderPos);

    double gapRefUm = (*argin)[0];
    double centerRefUm = (*argin)[1];
    
    offsetsGapVector[0]=gapRefUm/2+centerRefUm - convert_to_micrometers(encoderPos[0] - encoderPos[2], positionRatioPhase);
    offsetsGapVector[1]=gapRefUm/2+centerRefUm - convert_to_micrometers(encoderPos[1] - encoderPos[3], positionRatioPhase);
    offsetsGapVector[2]=gapRefUm/2+centerRefUm - convert_to_micrometers(encoderPos[2], positionRatioPhase);
    offsetsGapVector[3]=gapRefUm/2+centerRefUm - convert_to_micrometers(encoderPos[3], positionRatioPhase);

    // Update offsets on individual Galil axes as well on the DMC vector
    gapAxesGroup->write_attribute("offset", offsetsGapVector, false);
    comm->update_gap_encoder_offsets(offsetsGapVector,(1/positionRatioGap));

	/*----- PROTECTED REGION END -----*/	//	Undulator::calibrate_gap

}

//--------------------------------------------------------
/**
 *	Execute the CalibratePhase command:
 *	Description: Calculates phase axes offsets on zero phase.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::calibrate_phase()
{
	DEBUG_STREAM << "Undulator::CalibratePhase()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::calibrate_phase) ENABLED START -----*/

    Tango::GroupAttrReplyList replyList = phaseAxesGroup->read_attribute("position", false);
    if(replyList.has_failed() == 1)
            Tango::Except::throw_exception("Error in reading phase axes position attribute.",
                "Read_attribute function failed.","calibrate_phase()", Tango::ERR);

    // Get current offsets.
    get_offsets_phase();

    // Recalculate new offsets.
    // Offsets are equal to "old offset - current position" since we are a 0.
    double extractor;
    for(uint i = 0; i < replyList.size(); i++)
    {
        replyList[i] >> extractor;
        offsetsPhaseVector[i] -= extractor;
    }

    // Update offsets.
    phaseAxesGroup->write_attribute("offset", offsetsPhaseVector, false);


	/*----- PROTECTED REGION END -----*/	//	Undulator::calibrate_phase

}

//--------------------------------------------------------
/**
 *	Execute the LoadCorrectionData command:
 *	Description: Loads the interpolation data for the coil correction from a file.
 *	              
 *	             Load can not be called while running. The data could be shared with the thread without locking.
 *
 *	@param argin filename
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::load_correction_data(Tango::DevString argin)
{
	DEBUG_STREAM << "Undulator::LoadCorrectionData()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::load_correction_data) ENABLED START -----*/

	correctionCoils->load_correction_data(argin);

	/*----- PROTECTED REGION END -----*/	//	Undulator::load_correction_data

}

//--------------------------------------------------------
/**
 *	Execute the ResetDrive command:
 *	Description: Sends Drive-reset command to the appropriate motor drive (1..8)
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::reset_drive(Tango::DevUShort argin)
{
	DEBUG_STREAM << "Undulator::ResetDrive()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::reset_drive) ENABLED START -----*/

	comm->reset_drive(argin);

	/*----- PROTECTED REGION END -----*/	//	Undulator::reset_drive

}


	/*----- PROTECTED REGION ID(Undulator::namespace_ending) ENABLED START -----*/


void Undulator::update_position(const IDPosition &newPos)
{
	omni_mutex_lock guard(deviceLock);

	this->idPosition = newPos;
}

void Undulator::update_status(const IDStatus &newStatus)
{
	omni_mutex_lock guard(deviceLock);
	this->idStatus = newStatus;
}

void Undulator::update_cycle_time(double newTime) {
	omni_mutex_lock guard(deviceLock);
	this->cycleTime = newTime;
}

void Undulator::calculate_phase_motor_destinations(vector<double> &destinations)
{
    // Convert desiredOffset to counts.
    double counts = convert_to_counts(desiredOffset, positionRatioPhase);

    // Put all 4 destinations to 0.
    for(int i = 0; i < 4; i++)
        destinations.push_back(0);

    // Fix the two destinations based on phase mode.
    switch(desiredPhaseMode)
    {
        // Phase A - X1 and X4 fixed, X2 and X3 move parallel to desired offset.
        case 0:
            destinations[1] = counts;
            destinations[2] = counts;
            break;
        // Phase B - X2 and X3 fixed, X1 and X4 move parallel to desired offset.
        case 1:
            destinations[0] = counts;
            destinations[3] = counts;
            break;
        // Phase C - X1 and X4 fixed, X2 and X3 move antiparallel to desired offset.
        case 2:
            destinations[1] = counts;
            destinations[2] = -counts;
            break;
        // Phase D - X2 and X3 fixed, X1 and X4 move antiparallel to desired offset.
        case 3:
            destinations[0] = counts;
            destinations[3] = -counts;
            break;
        // Nothing to change leave all at phase center.
        default:
            break;
    }
}

void Undulator::get_offsets_gap()
{
    Tango::GroupAttrReplyList replyList = gapAxesGroup->read_attribute("offset", false);
    if(replyList.has_failed() == 1)
        Tango::Except::throw_exception("Error in reading gap offset attributes.",
            "Read_attribute function failed.","get_offsets_gap()", Tango::ERR);

    offsetsGapVector.clear();
    double extractor;

    for(uint i = 0; i < replyList.size(); i++)
    {
        replyList[i] >> extractor;
        offsetsGapVector.push_back(extractor);
    }
}

void Undulator::get_offsets_phase()
{
    Tango::GroupAttrReplyList replyList = phaseAxesGroup->read_attribute("offset", false);
    if(replyList.has_failed() == 1)
        Tango::Except::throw_exception("Error in reading phase offset attributes.",
            "Read_attribute function failed.","get_offsets_phase()", Tango::ERR);

    offsetsPhaseVector.clear();
    double extractor;

    for(uint i = 0; i < replyList.size(); i++)
    {
        replyList[i] >> extractor;
        offsetsPhaseVector.push_back(extractor);
    }
}

void Undulator::start_gap()
{
    // Deny move if in engineering mode.
    if(engineeringLock)
    {
        ERROR_STREAM << "Engineering lock is enabled. Movement denied." << endl;

        Tango::Except::throw_exception("Engineering lock enabled.",
                    "Move gap not permitted under engineering lock.","Move gap command.",Tango::WARN);
        return;
    }

    GapParameters parameters;

    // Update offsets.
    get_offsets_gap();

    parameters.gap = convert_to_counts(desiredGap, positionRatioGap);
    parameters.offset = convert_to_counts(desiredCenter, positionRatioGap);
    parameters.taper = convert_to_counts(desiredTaper, positionRatioGap);
    parameters.gapSpeed = convert_to_counts(gapSpeed, positionRatioGap);
    parameters.taperSpeed = convert_to_counts(taperSpeed, positionRatioGap);
    parameters.gapAcceleration = convert_to_counts(gapAcc, positionRatioGap);
    parameters.taperAcceleration = convert_to_counts(taperAcc, positionRatioGap);

    // Send to DMC.
    comm->update_gap_encoder_offsets(offsetsGapVector,(1/positionRatioGap));        
    comm->start_gap_movement(parameters);
}

void Undulator::start_phase()
{
    // If lock or operator wants too much offset we deny.
    if(engineeringLock)
    {
        ERROR_STREAM << "Engineering lock enabled. Movement denied." << endl;
        Tango::Except::throw_exception("Engineering lock or out of bounds max operator phase offset desired.",
                            "Move phase not permitted under current conditions","Start move phase command.",Tango::WARN);
        return;
    }

    PhaseParameters parameters;

    // Calculate final destinations and correct vector.
    calculate_phase_motor_destinations(parameters.finalAxisPos);

    // Update offsets.
    get_offsets_phase();

    // Set other needed parameters.
    parameters.phaseMode = desiredPhaseMode;
    parameters.phaseSpeed = convert_to_counts(phaseSpeed*VECTOR_UNIT_TO_INDIVIDUAL, positionRatioPhase);
    parameters.phaseAcceleration = convert_to_counts(phaseAcc*VECTOR_UNIT_TO_INDIVIDUAL, positionRatioPhase);

    // Send to DMC.
    comm->update_phase_encoder_offsets(offsetsPhaseVector,(1/positionRatioPhase));
    comm->start_phase_movement(parameters);
}

	/*----- PROTECTED REGION END -----*/	//	Undulator::namespace_ending
} //	namespace
