static const char *RcsId = "$Header: /usr/local/CVS/DeviceServer/Generic/Motorisation/ControlBoxV2/src/GalilAxis.cpp,v 1.44 2011/07/15 09:47:42 buteau Exp $";
//+=============================================================================
//
// file : 				GalilAxis.cpp
//
// description :	C++ source for the GalilAxis and its commands. 
//								The class is derived from Device. It represents the
//								CORBA servant object which will be accessed from the
//								network. All commands which can be executed on the
//								GalilAxis are implemented in this file.
//
// project :			TANGO Device Server
//
// $Author: buteau $
//
// $Revision: 1.44 $
//
// $Log: GalilAxis.cpp,v $
// Revision 1.44  2011/07/15 09:47:42  buteau
// MANTIS 19368
//
// Revision 1.42  2011/05/19 10:52:54  coquet
// some include path updated
// changes yat dependency order
//
//
// copyleft : 		European Synchrotron Radiation Facility
//								BP 220, Grenoble 38043
//								FRANCE
//
//-=============================================================================
//
//			This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//				 (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name                 |  Method name
//	----------------------------------------
//  State                        |  dev_state()
//  Status                       |  dev_status()
//  Forward                      |  forward()
//  Stop                         |  stop()
//  Backward                     |  backward()
//  InitializeReferencePosition  |  initialize_reference_position()
//  MotorOFF                     |  motor_off()
//  MotorON                      |  motor_on()
//  DefinePosition               |  define_position()
//  ComputeNewOffset             |  compute_new_offset()
//  On                           |  on()
//  Off                          |  off()
//  GetDetailOfState             |  get_detail_of_state()
//
//===================================================================

#include <tango.h>
#include <GalilAxis.h>
#include <GalilAxisClass.h>
#include <yat/utils/XString.h>
#include "InitTypeParser.h"
#include <DeviceProxyHelper.h>
#include <PogoHelper.h>
// ============================================================================
// MACRO: LOG_AXIS_STATUS
// ============================================================================
#define LOG_AXIS_STATUS(EAS, TS) \
  DEBUG_STREAM << "Axis::status: Axis-" \
               << galil::galil_axis_name[m_axis->identifier()] \
               << " - State: " \
               << Tango::DevStateName[TS] \
               << " - Status: " \
               << EAS.status \
               << " - TC error: " \
               << EAS.tc_error \
               << " - TC error txt: " \
               << EAS.tc_error_str \
               << std::endl;

namespace GalilAxis_ns
{


//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::GalilAxis(string &s)
// 
// description :	constructor for simulated GalilAxis
//
// in : - cl : Pointer to the DeviceClass object
//			- s : Device name 
//
//-----------------------------------------------------------------------------
GalilAxis::GalilAxis(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

GalilAxis::GalilAxis(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
	init_device();
}

GalilAxis::GalilAxis(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::delete_device()
// 
// description :	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void GalilAxis::delete_device()
{
  //- DEBUG_STREAM << "Entering GalilAxis::delete_device() " << std::endl;

  //- release our galil::Axis reference
  SAFE_RELEASE(this->m_axis);

	DELETE_SCALAR_ATTRIBUTE(attr_position_read);
	DELETE_SCALAR_ATTRIBUTE(attr_acceleration_read);
	DELETE_SCALAR_ATTRIBUTE(attr_deceleration_read);
	DELETE_SCALAR_ATTRIBUTE(attr_velocity_read);
	DELETE_SCALAR_ATTRIBUTE(attr_accuracy_read);
	DELETE_SCALAR_ATTRIBUTE(attr_backlash_read);
	DELETE_SCALAR_ATTRIBUTE(attr_offset_read);
	DELETE_SCALAR_ATTRIBUTE(attr_backwardLimitSwitch_read);
	DELETE_SCALAR_ATTRIBUTE(attr_forwardLimitSwitch_read);
  DELETE_SCALAR_ATTRIBUTE(attr_positionLocked_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::init_device()
// 
// description :	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void GalilAxis::init_device()
{
  //- DEBUG_STREAM << "GalilAxis::GalilAxis() create device " << device_name << std::endl;

	// Initialise variables to default values
	//--------------------------------------------
	this->m_status_str = "initializing device...";
	this->m_axis = 0;
	this->m_properties_missing = false;
	this->m_init_device_done = false;

  //- reset disabled commands table
	::memset(this->disabled_cmds, 0, (kCMD_LAST + 1) * sizeof(bool));

	CREATE_SCALAR_ATTRIBUTE(attr_position_read);
	CREATE_SCALAR_ATTRIBUTE(attr_acceleration_read);
	CREATE_SCALAR_ATTRIBUTE(attr_deceleration_read);
	CREATE_SCALAR_ATTRIBUTE(attr_velocity_read);
	CREATE_SCALAR_ATTRIBUTE(attr_accuracy_read, 2.0);
	CREATE_SCALAR_ATTRIBUTE(attr_backlash_read);
	CREATE_SCALAR_ATTRIBUTE(attr_offset_read);
	CREATE_SCALAR_ATTRIBUTE(attr_backwardLimitSwitch_read);
	CREATE_SCALAR_ATTRIBUTE(attr_forwardLimitSwitch_read);
  CREATE_SCALAR_ATTRIBUTE(attr_positionLocked_read);

  //- axis config: get axis identifier from <axisNumber> property
  try
  {
    this->get_device_property();
  }
  catch (const Tango::DevFailed &df)
  {
    ERROR_STREAM << df << std::endl;
    TangoSys_OMemStream oms;
    oms << "Tango exception caught while trying to read device properties from database";
	  ERROR_STREAM << oms.str()
                 << std::endl;
    this->m_status_str = oms.str();
    this->set_state(Tango::FAULT);
    return;
  }
  catch (...)
  {
    TangoSys_OMemStream oms;
    oms << "Unknown exception caught while trying to read device properties from database";
	  ERROR_STREAM << oms.str()
                 << std::endl;
    this->m_status_str = oms.str();
    this->set_state(Tango::FAULT);
    return;
  }

  if (this->m_properties_missing)
  {
    TangoSys_OMemStream oms;
	  oms << "One (or more) required properties is missing "
        << "[device initialization failed]"
        << std::ends;
    ERROR_STREAM << oms.str() << std::endl;
    this->m_status_str = oms.str();
    this->set_state(Tango::FAULT);
    return;
  }
  //- enable all cmd
  ::memset(this->disabled_cmds, 0, (kCMD_LAST + 1) * sizeof(bool));

  //- check property content...
  for (size_t c = 0; c < disabledCmds.size(); c++)
  {
    //- current cmd string
    std::string& cmd = disabledCmds[c];
    //- avoid case problems
    std::transform(cmd.begin(), cmd.end(), cmd.begin(), ::tolower);
    //- is it the Forward cmd?
    if (cmd == std::string(kCMD_FORWARD_NAME))
    {
       this->disabled_cmds[kCMD_FORWARD] = true;
       WARN_STREAM << "GalilAxis cmd <Forward> is disabled" << std::endl;
    }
    //- is it the Backward cmd?
    else if (cmd == std::string(kCMD_BACKWARD_NAME))
    {
       this->disabled_cmds[kCMD_BACKWARD] = true;
       WARN_STREAM << "GalilAxis cmd <Backward> is disabled" << std::endl;
    }
  }

  //- try to populate the galil::Axis::Config
  galil::Axis::Config axis_cfg;

  //- axis config: set the associated GalilAxis Tango device
  axis_cfg.host_device = this;

  //- axis config: get axis identifier from <axisNumber> property
  try
  {
    axis_cfg.id = galil::Axis::string_to_axis_id(axisNumber);
  }
  catch (const Tango::DevFailed &df)
  {
    ERROR_STREAM << df << std::endl;
    TangoSys_OMemStream oms;
    oms << "Invalid <AxisNumber> property "
        << "[device initialization failed]"
        << std::ends;
	  ERROR_STREAM << oms.str()
                 << ". Must be in [1..8] or [A..H] or [X,Y,Z,W]" 
                 << std::endl;
    this->m_status_str = oms.str();
    this->set_state(Tango::FAULT);
    return;
  }

  //- axis config: encoder_type
  switch (axisEncoderType)
	{
    case 0:
      //- DEBUG_STREAM << "GalilAxis::init_device::associated encoder type: NONE" << std::endl;
      axis_cfg.encoder_type = galil::Axis::ENC_NONE;
		  break;
	  case 1:
      //- DEBUG_STREAM << "GalilAxis::init_device::associated encoder type: INCREMENTAL" << std::endl;
      axis_cfg.encoder_type = galil::Axis::ENC_INCREMENTAL;
		  break;
	  case 2:
      //- DEBUG_STREAM << "GalilAxis::init_device::associated encoder type: ABSOLUTE" << std::endl;
      axis_cfg.encoder_type = galil::Axis::ENC_ABSOLUTE;
		  break;
    default:
			{
        TangoSys_OMemStream oms;
        oms << "Invalid <AxisEncoderType> property "
            << "[device initialization failed]"
            << std::ends;
	      ERROR_STREAM << oms.str()
                     << ". Must be 0 for NONE, 1 for INCREMENTAL or 2 for ABSOLUTE encoder" 
                     << std::endl;
        this->m_status_str = oms.str();
        this->set_state(Tango::FAULT);
        return;
			}
      break;
  } //- switch

  //- enable maintenance mode
  axis_cfg.enable_maintenance_mode = enableMaintenanceMode;

  //- enable error correction mode
  axis_cfg.enable_error_correction = enableErrorCorrection;

  //- allow remote cbox to work
  axis_cfg.allow_remote_cbox = allowRemoteCbox;

  //- axis config: encoder ratio
  axis_cfg.encoder_ratio = axisPositionRatio;

	//- if AxisEncoderPosition is < 0 we need to invert limit switches 
	//- in referencve position strategy too
	bool ls_invert_needed;
	ls_invert_needed = (axis_cfg.encoder_ratio < 0) ? true : false;

	//- axis config : InitType (parse string property)
  try
  {
	  InitTypeParser itp(axisInitType, ls_invert_needed);
    axis_cfg.init_type = itp.to_init_type_value();

    DEBUG_STREAM << "GalilAxis::init_device::InitType::" 
                 << std::hex 
                 << axis_cfg.init_type
                 << std::dec
                 << std::endl;
  }
  catch (Tango::DevFailed & df)
  {
  	ERROR_STREAM << df << std::endl;
    Tango::DevError origin_of_pb = df.errors[df.errors.length() - 1];
    this->m_status_str = "device initialization failed ["
                       + std::string(origin_of_pb.desc.in())
                       + std::string("]");
    this->set_state(Tango::FAULT);
    return;
  }
  catch (...)
  {
    ERROR_STREAM << "initialization failed [unknown exception caught]" << std::endl;
    this->m_status_str = "device initialization failed [unknown exception caught]";
    this->set_state(Tango::FAULT);
    return;
  }

  //- axis config: initial position
  axis_cfg.init_pos = axisInitPosition;

  //- axis config: initial position
  axis_cfg.init_velocity = axisInitVelocity;

  //- axis config: duty cycle enabled
  axis_cfg.duty_cycle_enabled = enableDutyCycle;

  //- axis config: percent
  axis_cfg.percent = percent;
  if (percent < 0.)
  {
    ERROR_STREAM << "invalid value for property 'Percent' [must be > 0]" << std::endl;
    this->m_status_str = "device initialization failed [invalid value for property 'Percent']";
    this->set_state(Tango::FAULT);
    return;
  }

  //- axis config: retry
  axis_cfg.retry = retry;

  //- axis config: settling_time
  axis_cfg.settling_time = settlingTime;

  //- axis config: position locking machnism
  axis_cfg.position_locking_constraint = lockedPositionConstraint;
  axis_cfg.position_locking_checking_period_secs = lockedPositionCheckingPeriodSecs;
  axis_cfg.position_locking_history_depth = lockedPositionHistoryDepth;
  axis_cfg.position_locking_avaraging_window_width = lockedPositionAveragingWindowWidth;

  //- attach axis to the the <Galil-Box>
  try
  {
    this->m_axis = AXIS_FACTORY->attach_axis(axis_cfg);
  }
  catch (Tango::DevFailed & df)
  {
  	ERROR_STREAM << df << std::endl;
    Tango::DevError origin_of_pb = df.errors[df.errors.length() - 1];
    this->m_status_str = "device initialization failed ["
                       + std::string(origin_of_pb.desc.in())
                       + std::string("]");
    this->set_state(Tango::FAULT);
    return;
  }
  catch (...)
  {
    ERROR_STREAM << "initialization failed [unknown exception caught]" << std::endl;
    this->m_status_str = "device initialization failed [unknown exception caught]";
    this->set_state(Tango::FAULT);
    return;
  }

  //- disable pos. locking
  try
  {
    if (this->m_axis->is_position_locked())
      this->m_axis->unlock_pos();
  }
  catch (Tango::DevFailed & df)
  {
  	ERROR_STREAM << df << std::endl;
    Tango::DevError origin_of_pb = df.errors[df.errors.length() - 1];
    this->m_status_str = "device initialization failed - could not disable <pos. locking> ["
                       + std::string(origin_of_pb.desc.in())
                       + std::string("]");
    this->set_state(Tango::FAULT);
    return;
  }
  catch (...)
  {
    ERROR_STREAM << "initialization failed - could not disable <pos. locking> [unknown exception caught]" << std::endl;
    this->m_status_str = "device initialization failed - could not disable <pos. locking> [unknown exception caught]";
    this->set_state(Tango::FAULT);
    return;
  }

  //- init pos. r/w values
  try
  {
    *attr_position_read = this->m_axis->abs_pos();
    attr_position_write = *attr_position_read;
  }
  catch (Tango::DevFailed & df)
  {
  	ERROR_STREAM << df << std::endl;
    Tango::DevError origin_of_pb = df.errors[df.errors.length() - 1];
    this->m_status_str = "device initialization failed - could not read axis pos. ["
                       + std::string(origin_of_pb.desc.in())
                       + std::string("]");
    this->set_state(Tango::FAULT);
    return;
  }
  catch (...)
  {
    ERROR_STREAM << "initialization failed - could not read axis pos. [unknown exception caught]" << std::endl;
    this->m_status_str = "device initialization failed - could not read axis pos. [unknown exception caught]";
    this->set_state(Tango::FAULT);
    return;
  }

  this->m_init_device_done = true;

  this->set_state(Tango::RUNNING);

  //- DEBUG_STREAM << "device successfully initialized" << std::endl;
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::get_device_property()
// 
// description :	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void GalilAxis::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------
  axisNumber = "";
  axisPositionRatio = 1.;
  axisEncoderType = -1;
  axisInitType = "DP;";
  axisInitPosition = 0;
  enableMaintenanceMode = false;
  enableErrorCorrection = false;
	allowRemoteCbox = false;
	enableDutyCycle = false;
	percent = 1.;
	retry = 5;
  settlingTime = 100;
  axisInitVelocity = 0.;

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("AxisNumber"));
	dev_prop.push_back(Tango::DbDatum("AxisPositionRatio"));
	dev_prop.push_back(Tango::DbDatum("AxisEncoderType"));
	dev_prop.push_back(Tango::DbDatum("AxisInitType"));
	dev_prop.push_back(Tango::DbDatum("AxisInitPosition"));
	dev_prop.push_back(Tango::DbDatum("EnableMaintenanceMode"));
	dev_prop.push_back(Tango::DbDatum("AllowRemoteCbox"));
	dev_prop.push_back(Tango::DbDatum("EnableDutyCycle"));
	dev_prop.push_back(Tango::DbDatum("Percent"));
	dev_prop.push_back(Tango::DbDatum("Retry"));
	dev_prop.push_back(Tango::DbDatum("DisabledCmds"));
	dev_prop.push_back(Tango::DbDatum("EnableErrorCorrection"));
	dev_prop.push_back(Tango::DbDatum("SettlingTime"));
	dev_prop.push_back(Tango::DbDatum("LockedPositionHistoryDepth"));
	dev_prop.push_back(Tango::DbDatum("LockedPositionConstraint"));
	dev_prop.push_back(Tango::DbDatum("LockedPositionCheckingPeriodSecs"));
	dev_prop.push_back(Tango::DbDatum("LockedPositionAveragingWindowWidth"));
	dev_prop.push_back(Tango::DbDatum("AxisInitVelocity"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	GalilAxisClass	*ds_class =
		(static_cast<GalilAxisClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize AxisNumber from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  axisNumber;
	else {
		//	Try to initialize AxisNumber from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  axisNumber;
	}
	//	And try to extract AxisNumber value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  axisNumber;

	//	Try to initialize AxisPositionRatio from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  axisPositionRatio;
	else {
		//	Try to initialize AxisPositionRatio from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  axisPositionRatio;
	}
	//	And try to extract AxisPositionRatio value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  axisPositionRatio;

	//	Try to initialize AxisEncoderType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  axisEncoderType;
	else {
		//	Try to initialize AxisEncoderType from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  axisEncoderType;
	}
	//	And try to extract AxisEncoderType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  axisEncoderType;

	//	Try to initialize AxisInitType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  axisInitType;
	else {
		//	Try to initialize AxisInitType from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  axisInitType;
	}
	//	And try to extract AxisInitType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  axisInitType;

	//	Try to initialize AxisInitPosition from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  axisInitPosition;
	else {
		//	Try to initialize AxisInitPosition from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  axisInitPosition;
	}
	//	And try to extract AxisInitPosition value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  axisInitPosition;

	//	Try to initialize EnableMaintenanceMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enableMaintenanceMode;
	else {
		//	Try to initialize EnableMaintenanceMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  enableMaintenanceMode;
	}
	//	And try to extract EnableMaintenanceMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableMaintenanceMode;

	//	Try to initialize AllowRemoteCbox from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  allowRemoteCbox;
	else {
		//	Try to initialize AllowRemoteCbox from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  allowRemoteCbox;
	}
	//	And try to extract AllowRemoteCbox value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  allowRemoteCbox;

	//	Try to initialize EnableDutyCycle from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enableDutyCycle;
	else {
		//	Try to initialize EnableDutyCycle from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  enableDutyCycle;
	}
	//	And try to extract EnableDutyCycle value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDutyCycle;

	//	Try to initialize Percent from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  percent;
	else {
		//	Try to initialize Percent from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  percent;
	}
	//	And try to extract Percent value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  percent;

	//	Try to initialize Retry from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  retry;
	else {
		//	Try to initialize Retry from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  retry;
	}
	//	And try to extract Retry value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  retry;

	//	Try to initialize DisabledCmds from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  disabledCmds;
	else {
		//	Try to initialize DisabledCmds from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  disabledCmds;
	}
	//	And try to extract DisabledCmds value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  disabledCmds;

	//	Try to initialize EnableErrorCorrection from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enableErrorCorrection;
	else {
		//	Try to initialize EnableErrorCorrection from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  enableErrorCorrection;
	}
	//	And try to extract EnableErrorCorrection value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableErrorCorrection;

	//	Try to initialize SettlingTime from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  settlingTime;
	else {
		//	Try to initialize SettlingTime from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  settlingTime;
	}
	//	And try to extract SettlingTime value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  settlingTime;

	//	Try to initialize LockedPositionHistoryDepth from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  lockedPositionHistoryDepth;
	else {
		//	Try to initialize LockedPositionHistoryDepth from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  lockedPositionHistoryDepth;
	}
	//	And try to extract LockedPositionHistoryDepth value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  lockedPositionHistoryDepth;

	//	Try to initialize LockedPositionConstraint from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  lockedPositionConstraint;
	else {
		//	Try to initialize LockedPositionConstraint from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  lockedPositionConstraint;
	}
	//	And try to extract LockedPositionConstraint value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  lockedPositionConstraint;

	//	Try to initialize LockedPositionCheckingPeriodSecs from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  lockedPositionCheckingPeriodSecs;
	else {
		//	Try to initialize LockedPositionCheckingPeriodSecs from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  lockedPositionCheckingPeriodSecs;
	}
	//	And try to extract LockedPositionCheckingPeriodSecs value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  lockedPositionCheckingPeriodSecs;

	//	Try to initialize LockedPositionAveragingWindowWidth from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  lockedPositionAveragingWindowWidth;
	else {
		//	Try to initialize LockedPositionAveragingWindowWidth from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  lockedPositionAveragingWindowWidth;
	}
	//	And try to extract LockedPositionAveragingWindowWidth value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  lockedPositionAveragingWindowWidth;

	//	Try to initialize AxisInitVelocity from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  axisInitVelocity;
	else {
		//	Try to initialize AxisInitVelocity from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  axisInitVelocity;
	}
	//	And try to extract AxisInitVelocity value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  axisInitVelocity;



	//	End of Automatic code generation
	//------------------------------------------------------------------
	Tango::DbData data_put;

  if (dev_prop[0].is_empty() || axisNumber.find("must be defined") != std::string::npos)
	{
		m_properties_missing = true;
		Tango::DbDatum	property("AxisNumber");
		property << "must be defined - select the associated axis in [A..H]";
		data_put.push_back(property);
    ERROR_STREAM << "undefined critical property <AxisNumber>" << std::endl;
	}

	if (dev_prop[1].is_empty())
	{
		Tango::DbDatum	property("AxisPositionRatio");
		property <<	axisPositionRatio;
		data_put.push_back(property);
    WARN_STREAM << "undefined <AxisPositionRatio> property - using default value" << std::endl;
	}

	if (dev_prop[2].is_empty() || axisEncoderType == -1)
	{
		m_properties_missing = true;
		Tango::DbDatum	property("AxisEncoderType");
		property << "must be defined - 0:none, 1:incremental, 2:absolute";
		data_put.push_back(property);
    ERROR_STREAM << "undefined critical property <AxisEncoderType>" << std::endl;
	}

	if (dev_prop[3].is_empty()|| axisInitType.find("must be defined") != std::string::npos)
	{
		m_properties_missing = true;
		Tango::DbDatum	property("AxisInitType");
		property << "must be defined [example: LSBWD:1;FI:2;FH:-3]";
		data_put.push_back(property);
    ERROR_STREAM << "undefined critical property <AxisInitType>" << std::endl;
	}

	if (dev_prop[4].is_empty())
	{
		Tango::DbDatum	property("AxisInitPosition");
		property <<	axisInitPosition;
		data_put.push_back(property);
    WARN_STREAM << "undefined <AxisInitPosition> property - using default value : 0.0" << std::endl;
	}

	if (dev_prop[5].is_empty())
	{
		Tango::DbDatum	property("EnableMaintenanceMode");
		property <<	enableMaintenanceMode;
		data_put.push_back(property);
    WARN_STREAM << "undefined <EnableMaintenanceMode> property - using default value : false" << std::endl;
	}

	if (dev_prop[6].is_empty())
	{
		Tango::DbDatum	property("AllowRemoteCbox");
		property <<	allowRemoteCbox;
		data_put.push_back(property);
    WARN_STREAM << "undefined <AllowRemoteCbox> property - using default value : false" << std::endl;
	}

	if (dev_prop[17].is_empty())
	{
		Tango::DbDatum	property("AxisInitVelocity");
		property <<	axisInitVelocity;
		data_put.push_back(property);
    WARN_STREAM << "undefined <AxisInitVelocity> property - using default value : 0. (use valocity attribute value)" << std::endl;
	}

	if (disabledCmds.size())
	{
    for (size_t c = 0; c < disabledCmds.size(); c++)
      WARN_STREAM << "GalilAxis cmd <" << disabledCmds[c] << "> is disabled" << std::endl;
	}

	if (! data_put.empty())
		get_db_device()->put_property(data_put);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::check_init()
//
// description :
//
//-----------------------------------------------------------------------------
void GalilAxis::check_init () 
    throw (Tango::DevFailed)
{
	if (! this->m_init_device_done || ! this->m_axis) 
  {
    THROW_DEVFAILED(_CPTC("INITIALIZATION_FAILED"),
                    _CPTC("request rejected - device is not properly initialized"),
                    _CPTC("GalilAxis::check_init"));		
	}
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::always_executed_hook()
//
// description :	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void GalilAxis::always_executed_hook()
{

}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_attr_hardware
//
// description :	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_attr_hardware(vector<long> &attr_list)
{
  this->check_init ();

	//- DEBUG_STREAM << "GalilAxis::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_lockedPositionHistory
// 
// description : 	Extract real attribute values for lockedPositionHistory acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_lockedPositionHistory(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_lockedPositionHistory(Tango::Attribute &attr) entering... "<< endl;

  const galil::LockedPositionHistory & lph = this->m_axis->correction_history();

  attr.set_value(lph.m_data, lph.m_w, lph.m_h);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_positionLocked
// 
// description : 	Extract real attribute values for positionLocked acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_positionLocked(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_positionLocked(Tango::Attribute &attr) entering... "<< endl;

	*attr_positionLocked_read = this->m_axis->is_position_locked();

  attr.set_value(attr_positionLocked_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::write_positionLocked
// 
// description : 	Write positionLocked attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilAxis::write_positionLocked(Tango::WAttribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::write_positionLocked(Tango::WAttribute &attr) entering... "<< endl;

  this->check_init ();

	attr.get_write_value(attr_positionLocked_write);

  if (attr_positionLocked_write)
  {
    *attr_position_read = this->m_axis->abs_pos();
    this->m_axis->lock_pos(*attr_position_read);
  }
  else
  {
    this->m_axis->unlock_pos();
  }
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_backwardLimitSwitch
// 
// description : 	Extract real attribute values for backwardLimitSwitch acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_backwardLimitSwitch(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_backwardLimitSwitch(Tango::Attribute &attr) entering... "<< endl;

	*attr_backwardLimitSwitch_read = this->m_axis->backward_limit_switch_detected();

  attr.set_value(attr_backwardLimitSwitch_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_forwardLimitSwitch
// 
// description : 	Extract real attribute values for forwardLimitSwitch acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_forwardLimitSwitch(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_forwardLimitSwitch(Tango::Attribute &attr) entering... "<< endl;

	//- limit switch depends on "user direction" defined by AxisPositionRatio property sign
	*attr_forwardLimitSwitch_read = this->m_axis->forward_limit_switch_detected();

  attr.set_value(attr_forwardLimitSwitch_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_position
//
// description :	Extract real attribute values for position acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_position(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_position(Tango::Attribute &attr) entering... "<< endl;

	Tango::AttrQuality q = Tango::ATTR_VALID;

	//- check positioning error
	const galil::ExtendedAxisStatus & eas = this->m_axis->extended_axis_status(
			false);
#if ! defined(USE_REF_POS)
	if (eas.ucas.pos_err())
		q = Tango::ATTR_ALARM;
#endif

	*attr_position_read = this->m_axis->abs_pos();

	attr.set_value(attr_position_read);

	if (q != Tango::ATTR_VALID)
		attr.set_quality(q, false);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::write_position
// 
// description :	Write position attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilAxis::write_position(Tango::WAttribute &attr)
{
  //- DEBUG_STREAM << "GalilAxis::write_position(Tango::WAttribute &attr) entering... "<< endl;

  this->check_init ();

	//- provisoire : passer l'axe en disable quand il est en gearing master ou slave
	if (this->m_axis->gearing_enabled()) 
  {
    THROW_DEVFAILED(_CPTC("NOT_ALLOWED"),
                    _CPTC("request rejected - Axis is in gearing mode [set independant mode on slit first]"),
                    _CPTC("GalilAxis::write_position"));		
	}

	attr.get_write_value(attr_position_write);

  this->m_axis->abs_pos(attr_position_write);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_acceleration
// 
// description :	Extract real attribute values for acceleration acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_acceleration(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_acceleration(Tango::Attribute &attr) entering... "<< endl;

  try
  {
	  *attr_acceleration_read = this->m_axis->acceleration();
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::acceleration" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::acceleration"),
                    _CPTC("GalilAxis::read_acceleration"));
  }

	attr.set_value(attr_acceleration_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::write_acceleration
// 
// description :	Write acceleration attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilAxis::write_acceleration(Tango::WAttribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::write_acceleration(Tango::WAttribute &attr) entering... "<< endl;

  this->check_init ();

  attr.get_write_value(attr_acceleration_write);
 
  try
  {
    this->m_axis->acceleration(attr_acceleration_write);
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::acceleration" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::acceleration"),
                    _CPTC("GalilAxis::write_acceleration"));
  }
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_deceleration
//
// description :	Extract real attribute values for deceleration acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_deceleration(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_deceleration(Tango::Attribute &attr) entering... "<< endl;
  
  try
  {
    *attr_deceleration_read = this->m_axis->deceleration();
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::deceleration" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::deceleration"),
                    _CPTC("GalilAxis::read_deceleration"));
  }
  
  attr.set_value(attr_deceleration_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::write_deceleration
//
// description :	Write deceleration attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilAxis::write_deceleration(Tango::WAttribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::write_deceleration(Tango::WAttribute &attr) entering... "<< endl;
	
  this->check_init ();

  attr.get_write_value(attr_deceleration_write);

  try
  {
    this->m_axis->deceleration(attr_deceleration_write);
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::deceleration" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::deceleration"),
                    _CPTC("GalilAxis::write_deceleration"));
  }
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_velocity
//
// description :	Extract real attribute values for velocity acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_velocity(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_velocity(Tango::Attribute &attr) entering... "<< endl;

  try
  {
    *attr_velocity_read = this->m_axis->velocity();
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::velocity" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::velocity"),
                    _CPTC("GalilAxis::read_velocity"));
  }
  
	attr.set_value(attr_velocity_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::write_velocity
//
// description :	Write velocity attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilAxis::write_velocity(Tango::WAttribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::write_velocity(Tango::WAttribute &attr) entering... "<< endl;
	
  this->check_init ();

  attr.get_write_value(attr_velocity_write);

  try
  {
    this->m_axis->velocity(attr_velocity_write);
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::velocity" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::velocity"),
                    _CPTC("GalilAxis::write_velocity"));
  }
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_accuracy
//
// description :	Extract real attribute values for accuracy acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_accuracy(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_accuracy(Tango::Attribute &attr) entering... "<< endl;

  try
  {
    *attr_accuracy_read = this->m_axis->accuracy();
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::accuracy" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::accuracy"),
                    _CPTC("GalilAxis::read_accuracy"));
  }
  
	attr.set_value(attr_accuracy_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::write_accuracy
//
// description :	Write accuracy attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilAxis::write_accuracy(Tango::WAttribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::write_accuracy(Tango::WAttribute &attr) entering... "<< endl;
		
  this->check_init ();

	attr.get_write_value(attr_accuracy_write);

  try
  {
    this->m_axis->accuracy(attr_accuracy_write);
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::accuracy" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::accuracy"),
                    _CPTC("GalilAxis::write_accuracy"));
  }
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_backlash
//
// description :	Extract real attribute values for backlash acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_backlash(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_backlash(Tango::Attribute &attr) entering... "<< endl;

  try
  {
    *attr_backlash_read = this->m_axis->backlash();
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::backlash" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::backlash"),
                    _CPTC("GalilAxis::read_backlash"));
  }
  
	attr.set_value(attr_backlash_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::write_backlash
//
// description :	Write backlash attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilAxis::write_backlash(Tango::WAttribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::write_backlash(Tango::WAttribute &attr) entering... "<< endl;

  this->check_init ();

	attr.get_write_value(attr_backlash_write);

  try
  {
    this->m_axis->backlash(attr_backlash_write);
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::backlash" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::backlash"),
                    _CPTC("GalilAxis::write_backlash"));
  }
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::read_offset
//
// description :	Extract real attribute values for offset acquisition result.
//
//-----------------------------------------------------------------------------
void GalilAxis::read_offset(Tango::Attribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::read_offset(Tango::Attribute &attr) entering... "<< endl;

  try
  {
    *attr_offset_read = this->m_axis->offset();
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::offset" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::offset"),
                    _CPTC("GalilAxis::read_offset"));
  }
  
	attr.set_value(attr_offset_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilAxis::write_offset
//
// description :	Write offset attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilAxis::write_offset(Tango::WAttribute &attr)
{
	//- DEBUG_STREAM << "GalilAxis::write_offset(Tango::WAttribute &attr) entering... "<< endl;

  this->check_init ();

	attr.get_write_value(attr_offset_write);

  try
  {
    this->m_axis->offset(attr_offset_write);
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::offset" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::offset"),
                    _CPTC("GalilAxis::write_offset"));
  }
}

//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::forward
 *
 *	description:	method to execute "Forward"
 *	Start the movement in the positive way
 *
 *
 */
//+------------------------------------------------------------------
void GalilAxis::forward()
{
	//- DEBUG_STREAM << "GalilAxis::forward(): entering... !" << endl;

  this->check_init ();

  //- is the cmd enabled?
  if (this->disabled_cmds[kCMD_FORWARD] == true)
  {
    THROW_DEVFAILED(_CPTC("NOT_ALLOWED"),
                    _CPTC("request rejected - cmd is disabled by device configuration - check DisabledCmds property"),
                    _CPTC("GalilAxis::forward"));		
	}

	//- provisoire : passer l'axe en disable quand il est en gearing master ou slave
	if (this->m_axis->gearing_enabled()) 
  {
    THROW_DEVFAILED(_CPTC("NOT_ALLOWED"),
                    _CPTC("request rejected - Axis is in gearing mode [set independant mode on slit first]"),
                    _CPTC("GalilAxis::forward"));		
	}

  try
  {
    this->m_axis->forward();  
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::forward" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::forward"),
                    _CPTC("GalilAxis::forward"));
  }
}

//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::stop
 *
 *	description:	method to execute "Stop"
 *
 *
 */
//+------------------------------------------------------------------
void GalilAxis::stop()
{
	//- DEBUG_STREAM << "GalilAxis::stop(): entering... !" << endl;

  this->check_init ();
  
  try
  {
    this->m_axis->stop();  
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::stop" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::stop"),
                    _CPTC("GalilAxis::stop"));
  }
}

//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::backward
 *
 *	description:	method to execute "Backward"
 *	Start the movement in the negative way
 *
 *
 */
//+------------------------------------------------------------------
void GalilAxis::backward()
{
	//- DEBUG_STREAM << "GalilAxis::backward(): entering... !" << endl;

  this->check_init ();
  
  //- is the cmd enabled?
  if (this->disabled_cmds[kCMD_BACKWARD] == true)
  {
    THROW_DEVFAILED(_CPTC("NOT_ALLOWED"),
                    _CPTC("request rejected - cmd is disabled by device configuration - check DisabledCmds property"),
                    _CPTC("GalilAxis::backward"));		
	}

	//- provisoire : passer l'axe en disable quand il est en gearing master ou slave
	if (this->m_axis->gearing_enabled()) 
  {
    THROW_DEVFAILED(_CPTC("NOT_ALLOWED"),
                    _CPTC("request rejected - Axis is in gearing mode [set independant mode on slit first]"),
                    _CPTC("GalilAxis::backward"));		
	}

  try
  {
    this->m_axis->backward(); 
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::backward" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::backward"),
                    _CPTC("GalilAxis::backward"));
  }
}

//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::initialize_reference_position
 *
 *	description:	method to execute "InitializeReferencePosition"
 *	requests an initialization of axis
 *	initialization type as described in AxisInitType Proerty
 *	if initialisation success, after completion of initialization routine the axis position will be set
 *	at AxisInitPosition in encoder units
 *
 *
 */
//+------------------------------------------------------------------
void GalilAxis::initialize_reference_position()
{
	//- DEBUG_STREAM << "GalilAxis::initialize_reference_position(): entering... !" << endl;
  
  this->check_init ();
  
  try
  {
    this->m_axis->init_reference_position(); 
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::init_reference_position" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::init_reference_position"),
                    _CPTC("GalilAxis::initialize_reference_position"));
  }
}

//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::motor_off
 *
 *	description:	method to execute "MotorOFF"
 *	Disable the power amplifier of the motor
 *	DEPRECATED use Off command
 *
 *
 */
//+------------------------------------------------------------------
void GalilAxis::motor_off()
{
	//- DEBUG_STREAM << "GalilAxis::motor_off(): entering... !" << endl;
	INFO_STREAM << "GalilAxis::motor_off (): DEPRECATED COMMAND You should Use Off command !" << endl;
  this->off ();

}

//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::off
 *
 *	description:	method to execute "Off"
 *	disables power on the amplifier
 *
 *
 */
//+------------------------------------------------------------------
void GalilAxis::off()
{
	//- DEBUG_STREAM << "GalilAxis::off(): entering... !" << endl;

	//	Add your own code to control device here

  this->check_init ();

  try
  {
    this->m_axis->off();
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::off" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::off"),
                    _CPTC("GalilAxis::off"));
  }	INFO_STREAM << "GalilAxis::motor_on(): DEPRECATED COMMAND You should Use On command !" << endl;

}

//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::motor_on
 *
 *	description:	method to execute "MotorON"
 *	Enables the power amplifier of the motor
 *	DEPRECATED use On command
 *
 *
 */
//+------------------------------------------------------------------
void GalilAxis::motor_on()
{
	//- DEBUG_STREAM << "GalilAxis::motor_on(): entering... !" << endl;
	INFO_STREAM << "GalilAxis::motor_on(): DEPRECATED COMMAND You should Use On command !" << endl;
  this->on ();

}

//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::on
 *
 *	description:	method to execute "On"
 *	enables power on the amplifier
 *
 *
 */
//+------------------------------------------------------------------
void GalilAxis::on()
{
	//- DEBUG_STREAM << "GalilAxis::on(): entering... !" << endl;

	//	Add your own code to control device here

  this->check_init ();

  try
  {
    this->m_axis->on();
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::on" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::on"),
                    _CPTC("GalilAxis::on"));
  }
}
//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::define_position
 *
 *	description:	method to execute "DefinePosition"
 *	set the position at ( encoder units ) position
 *
 * @param	argin	initialisation position in encoder units
 *
 */
//+------------------------------------------------------------------
void GalilAxis::define_position(Tango::DevDouble argin)
{
	//- DEBUG_STREAM << "GalilAxis::define_position(): entering... !" << endl;

  this->check_init ();

	//	Add your own code to control device here
	try
  {
    this->m_axis->define_position (argin);
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::define_position" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis:define_position"),
                    _CPTC("GalilAxis::define_position"));
  }
}

//+------------------------------------------------------------------
/**
* method: GalilAxis::dev_state
*
* description:    method to execute "DevState"
* Command to read the device state.
* The method dev_state() override a DeviceImpl class virtual method.
*
* @return State Code
*
*/
//+------------------------------------------------------------------
Tango::DevState GalilAxis::dev_state()
{
  //- DEBUG_STREAM << "GalilAxis::dev_state(): entering... !" << endl;

	//- is device properly initialized?
	if (! m_init_device_done ||  m_properties_missing || ! m_axis) 
  {
		this->set_state(Tango::FAULT);
    return Tango::FAULT;
	}
	
	try
	{
	  //- provisoire : passer l'axe en disable quand il est en gearing master ou slave
	  if (this->m_axis->gearing_enabled()) 
    {
		  this->set_state(Tango::DISABLE);
      return Tango::DISABLE;
	  }
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    this->set_state(Tango::FAULT);
    return Tango::FAULT;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::gearing_enable in GalilAxis::dev_state" << std::endl;
    this->set_state(Tango::FAULT);
    return Tango::FAULT;
  }
  
  switch (this->m_axis->state())
  {
    case galil::AXIS_OFF:
	    this->set_state(Tango::OFF);
      return Tango::OFF;
      break;
    case galil::AXIS_MOVING:
	    this->set_state(Tango::MOVING);
      return Tango::MOVING;
      break;
    case galil::AXIS_STANDBY:
	    this->set_state(Tango::STANDBY);
      return Tango::STANDBY;
      break;
    case galil::AXIS_ALARM:
	    this->set_state(Tango::ALARM);
      return Tango::ALARM;
      break;
    case galil::AXIS_ERROR:
	    this->set_state(Tango::FAULT);
      return Tango::FAULT;
      break;
    case galil::AXIS_CRTL_DISABLED:
	    this->set_state(Tango::DISABLE);
      return Tango::DISABLE;
      break;
    default:
      break;
  }

  this->set_state(Tango::UNKNOWN);
  
  return Tango::UNKNOWN;
}


//+------------------------------------------------------------------
/**
* method: GalilAxis::dev_status
*
* description:    method to execute "DevStatus"
* Command to read the device status.
* The method dev_status() override a DeviceImpl class virtual method.
*
* @return Status descrition
*
*/
//+------------------------------------------------------------------
Tango::ConstDevString GalilAxis::dev_status()
{
  //- DEBUG_STREAM << "GalilAxis::dev_status(): entering... !" << endl;
  
  //- is device properly initialized?
	if (this->m_properties_missing) 
	{
    this->set_state(Tango::FAULT);
		this->m_status_str = "device initialization failed [undefined critical device properties]";
		this->set_status(this->m_status_str.c_str());
		return this->m_status_str.c_str();
	}

  //- is device properly initialized?
	if (! this->m_init_device_done)
	{
    this->set_state(Tango::FAULT);
    this->set_status(this->m_status_str.c_str());
    return m_status_str.c_str();
	}

  galil::AxisStatus es;
  
  try
  {
    this->m_axis->status(es);
    
    this->m_status_str = es.status;
  }
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    this->m_status_str = "Tango exception caught while trying to access Axis::status";
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::status in GalilAxis::dev_status" << std::endl;
    this->m_status_str = "unknown exception caught while trying to access Axis::status";
  }

  return m_status_str.c_str();
}

//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::compute_new_offset
 *
 *	description:	method to execute "ComputeNewOffset"
 *	use:
 *	if you want to be here and now at the user position X, call that method, passing X as argument.
 *	The new offset will be computed and applied.
 *
 * @param	argin	the position you want to have here and now
 *
 */
//+------------------------------------------------------------------
void GalilAxis::compute_new_offset(Tango::DevDouble argin)
{
	//- DEBUG_STREAM << "GalilAxis::compute_new_offset(): entering... !" << endl;

	//	Add your own code to control device here

  try
  {
	  if (this->m_axis->state() == galil::AXIS_MOVING)
    {
      THROW_DEVFAILED(_CPTC("COMMAND_NOT_ALLOWED"),
                      _CPTC("request rejected - use only if device is not MOVING"),
                      _CPTC("GalilAxis::compute_new_offset"));		

	  }
	}
  catch (Tango::DevFailed & df)
  {
    ERROR_STREAM << df << std::endl;
    throw;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught from Axis::state" << std::endl;
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught from Axis::state"),
                    _CPTC("GalilAxis::compute_new_offset"));
  }

	//- get real position
	double real_pos = this->m_axis->abs_pos() - this->m_axis->offset();

	//- try to write the attribute offset through DeviceProxy (attribute is memorized)
	try
	{
		Tango::DeviceProxyHelper me(this->device_name, this);
		me.write_attribute("offset", (argin - real_pos));
	}
  catch(Tango::DevFailed &e)
	{
		ERROR_STREAM << "GalilAxis::compute_new_offset SOFTWARE_ERROR cannot get a deviceproxy \
			               on myself catched DevFailed " << e << std::endl;
    RETHROW_DEVFAILED(e,
			                _CPTC("SOFTWARE_ERROR"),
                      _CPTC("cannot get a deviceproxy on myself"),
                      _CPTC("GalilAxis::compute_new_offset") );		

	}
  catch(...)
	{
		ERROR_STREAM << "GalilAxis::compute_new_offset SOFTWARE_ERROR cannot get a deviceproxy \
			               on myself catched Unknown Exception" << std::endl;
    THROW_DEVFAILED(_CPTC("SOFTWARE_ERROR"),
                    _CPTC("cannot get a deviceproxy on myself"),
                    _CPTC("GalilAxis::compute_new_offset") );		

	}
}

//+------------------------------------------------------------------
/**
 *	method:	GalilAxis::get_detail_of_state
 *
 *	description:	method to execute "GetDetailOfState"
 *	returns the value the detail requested (return true or false)
 *	
 *	1=Axis positionning failed
 *	2=Axis not initialised
 *	Other = returns false
 *
 * @param	argin	detail : [1=Axis positionning failed|2=Axis not initialised]
 * @return	bool value related to Argin
 *
 */
//+------------------------------------------------------------------
Tango::DevBoolean GalilAxis::get_detail_of_state(Tango::DevLong argin)
{
	//- DEBUG_STREAM << "GalilAxis::get_detail_of_state(): entering... !" << endl;

 //- check positioning error
  const galil::ExtendedAxisStatus & eas = this->m_axis->extended_axis_status(false);

  bool b = false;

	//	add your own code to control device here
  switch (argin)
  {
    case 1: 
      b = eas.ucas.pos_err();
      break;
    case 2:
      b = ! eas.ucas.ref_pos_done ();
      break;
    default:
      break;
  }

  return b;
}











}	//	namespace
