static const char *RcsId = "$Header: /usr/local/CVS/DeviceServer/Generic/Motorisation/ControlBoxV2/src/GalilSlit.cpp,v 1.14 2011/07/15 09:47:43 buteau Exp $";
//+=============================================================================
//
// file :         GalilSlit.cpp
//
// description :  C++ source for the GalilSlit and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                GalilSlit are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: buteau $
//
// $Revision: 1.14 $
//
// $Log: GalilSlit.cpp,v $
// Revision 1.14  2011/07/15 09:47:43  buteau
// MANTIS 19368
//
// Revision 1.13  2011/07/15 09:40:53  buteau
// MANTIS 19368
//
// Revision 1.12  2011/05/19 10:52:44  coquet
// some include path updated
// changes yat dependency order
//
// Revision 1.11  2010/03/26 09:17:39  maven
// "Migration_Tango7_Part2"
//
// Revision 1.10  2010/02/09 12:59:27  coquet
// GalilSlit
// added commands ComputeGapOffset ComputePositionOffset
//
// Revision 1.9  2010/01/13 09:54:31  coquet
// added commands On Off to GalilSlit
//
// Revision 1.8  2008/10/20 13:24:47  coquet
// added property IsGapPosition to GalilSlit (support for Gap and Position type slits)
//
// Revision 1.7  2007/11/30 09:57:15  coquet
// added slit support :
// now supports independant moving (not geared moving) for better positionning accuracy for "bad mecanics" slits
// very minor change to CoupledAxes class (linux compilation warning correction)
//
// Revision 1.6  2007/10/12 14:24:36  coquet
// attributes positionOffset and gapOffset are now memorized / write on HW at init
// tested under W32
//
// Revision 1.5  2007/04/20 09:15:10  coquet
// bug correction on Slit::position :
// compute of new position to reach
// bug correction in GalilSlit :
// gapOffset was not added to gap
// positionOffset was not added to position
//
// Revision 1.4  2007/04/19 08:26:24  coquet
// AxisRawDataReader :
// added 3 attributes
// * axisLetter
// * latchInput
// * homeInput
// GalilSSlit :
// * added tips in Status to come out of Limit switchs if necessary
// * added boolean property InvertPositionDirection to allow user to invert the positive direction if necessary
// GalilAxis :
// * attribute position is in ALARM if positionning failed
// * internal "EncoderMotorRatio" is set to 1.0 when motor is servo (according to bit 0 of Stat[x])  or if stepper motor has no encoder.
//
// Revision 1.3  2007/02/13 12:09:12  leclercq
// Changed some Slit and Axis behaviours
//
// Revision 1.2  2007/02/06 13:51:16  coquet
// added State and Status support in Slit class and GalilSlit device
//
// Revision 1.1  2007/01/31 13:14:33  leclercq
// Added more Slit support
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name              |  Method name
//	----------------------------------------
//  State                     |  dev_state()
//  Status                    |  dev_status()
//  Stop                      |  stop()
//  SetIndependantMode        |  set_independant_mode()
//  Off                       |  off()
//  On                        |  on()
//  ComputeNewGapOffset       |  compute_new_gap_offset()
//  ComputeNewPositionOffset  |  compute_new_position_offset()
//
//===================================================================


#include <tango.h>
#include <GalilSlit.h>
#include <GalilSlitClass.h>
#include <PogoHelper.h>

namespace GalilSlit_ns
{

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::GalilSlit(string &s)
// 
// description : 	constructor for simulated GalilSlit
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
GalilSlit::GalilSlit(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

GalilSlit::GalilSlit(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
	init_device();
}

GalilSlit::GalilSlit(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void GalilSlit::delete_device()
{
	//	Delete device's allocated object

	// delete read attributes
	DELETE_SCALAR_ATTRIBUTE(attr_gap_read);
	DELETE_SCALAR_ATTRIBUTE(attr_position_read);
	DELETE_SCALAR_ATTRIBUTE(attr_insideUpPosition_read);
	DELETE_SCALAR_ATTRIBUTE(attr_outsideDownPosition_read);
	DELETE_SCALAR_ATTRIBUTE(attr_positionOffset_read);
	DELETE_SCALAR_ATTRIBUTE(attr_gapOffset_read);

  //- release the Slit object
  if (this->m_slit)
  {
    delete this->m_slit;
    this->m_slit = 0;
  }

}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void GalilSlit::init_device()
{
	INFO_STREAM << "GalilSlit::GalilSlit() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	this->m_status_str = "initializing device...";
	this->m_init_device_done = false;
  this->m_slit = 0;

	// create read attributes
	CREATE_SCALAR_ATTRIBUTE(attr_gap_read);
	CREATE_SCALAR_ATTRIBUTE(attr_position_read);
	CREATE_SCALAR_ATTRIBUTE(attr_insideUpPosition_read);
	CREATE_SCALAR_ATTRIBUTE(attr_outsideDownPosition_read);
	CREATE_SCALAR_ATTRIBUTE(attr_positionOffset_read);
	CREATE_SCALAR_ATTRIBUTE(attr_gapOffset_read);
	
	get_device_property();
  if (this->m_properties_missing)
  {
    TangoSys_OMemStream oms;
	  oms << "One (or more) required properties is missing "
        << "[device initialization failed]" 
        << std::ends;
    ERROR_STREAM << oms.str() << std::endl;
    this->m_status_str = oms.str();
		this->m_init_device_done = false;
    this->set_state(Tango::FAULT);
    return;
  }

  try
  {
    //- instanciate the Slit object
    if (isGapPosition)
      this->m_slit = new galil::GapPositionSlit();
	  else if (isGeared)
	    this->m_slit = new galil::GearedSlit();
	  else
	    this->m_slit = new galil::IndependantSlit();

    if (this->m_slit == 0)
      throw std::bad_alloc();
  }
  catch (std::bad_alloc&)
  {
  	ERROR_STREAM << "device initialization failed [OUT OF MEMORY]" << std::endl;
    this->m_init_device_done = false;
    this->m_status_str = "device initialization failed [OUT OF MEMORY]";
    this->set_state(Tango::FAULT);
    return;
  }
  catch (...)
  {
    ERROR_STREAM << "initialization failed [unknown exception caught]" << std::endl;
    this->m_status_str = "device initialization failed [unknown exception caught]";
    this->m_init_device_done = false;
    this->set_state(Tango::FAULT);
    return;
  }

  try
  {
    //- instanciate the Slit object
    galil::AbstractSlit::Config slit_cfg;
    slit_cfg.master = galil::Axis::string_to_axis_id(insideUpAxis);
    slit_cfg.slave = galil::Axis::string_to_axis_id(outsideDownAxis);
    slit_cfg.invert_pos_dir = invertPositionDirection;
    slit_cfg.host_device = this;
    this->m_slit->configure(slit_cfg);
  }
  catch (Tango::DevFailed& df)
  {
  	ERROR_STREAM << df << std::endl;
    this->m_init_device_done = false;
    this->m_status_str = "slit configuration failed";
    this->set_state(Tango::FAULT);
    return;
  }
  catch (...)
  {
    ERROR_STREAM << "Slit configuration failed [unknown exception caught]" << std::endl;
    this->m_status_str = "slit configuration failed [unknown exception caught]";
    this->m_init_device_done = false;
    this->set_state(Tango::FAULT);
    return;
  }

	this->m_init_device_done = true;
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void GalilSlit::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------
	isGeared = true;

	this->m_properties_missing = false;
	this->invertPositionDirection = false;
	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("InsideUpAxis"));
	dev_prop.push_back(Tango::DbDatum("OutsideDownAxis"));
	dev_prop.push_back(Tango::DbDatum("InvertPositionDirection"));
	dev_prop.push_back(Tango::DbDatum("IsGeared"));
	dev_prop.push_back(Tango::DbDatum("IsGapPosition"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	GalilSlitClass	*ds_class =
		(static_cast<GalilSlitClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize InsideUpAxis from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  insideUpAxis;
	else {
		//	Try to initialize InsideUpAxis from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  insideUpAxis;
	}
	//	And try to extract InsideUpAxis value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  insideUpAxis;

	//	Try to initialize OutsideDownAxis from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  outsideDownAxis;
	else {
		//	Try to initialize OutsideDownAxis from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  outsideDownAxis;
	}
	//	And try to extract OutsideDownAxis value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  outsideDownAxis;

	//	Try to initialize InvertPositionDirection from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  invertPositionDirection;
	else {
		//	Try to initialize InvertPositionDirection from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  invertPositionDirection;
	}
	//	And try to extract InvertPositionDirection value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  invertPositionDirection;

	//	Try to initialize IsGeared from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  isGeared;
	else {
		//	Try to initialize IsGeared from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  isGeared;
	}
	//	And try to extract IsGeared value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  isGeared;

	//	Try to initialize IsGapPosition from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  isGapPosition;
	else {
		//	Try to initialize IsGapPosition from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  isGapPosition;
	}
	//	And try to extract IsGapPosition value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  isGapPosition;



	//	End of Automatic code generation
	//------------------------------------------------------------------
  Tango::DbData data_put;
  if (dev_prop[0].is_empty() || insideUpAxis.find("must be defined") != std::string::npos)
	{
		m_properties_missing = true;
		Tango::DbDatum	property("InsideUpAxis");
		property << "must be defined - select the associated axis in [A..H]";
		data_put.push_back(property);
    ERROR_STREAM << "undefined critical property <InsideUpAxis>" << std::endl;
	}
  if (dev_prop[1].is_empty() || outsideDownAxis.find("must be defined") != std::string::npos)
	{
		m_properties_missing = true;
		Tango::DbDatum	property("OutsideDownAxis");
		property << "must be defined - select the associated axis in [A..H]";
		data_put.push_back(property);
    ERROR_STREAM << "undefined critical property <InsideUpAxis>" << std::endl;
	}
  if (dev_prop[2].is_empty() )
	{
		Tango::DbDatum	property("InvertPositionDirection");
		property << false;
		data_put.push_back(property);
	}
  if (dev_prop[3].is_empty() )
	{
		Tango::DbDatum	property("IsGeared");
		property << true;
		data_put.push_back(property);
	}
  if (dev_prop[4].is_empty() )
	{
		Tango::DbDatum	property("IsGapPosition");
		property << false;
		data_put.push_back(property);
	}
	if (! data_put.empty())
		get_db_device()->put_property(data_put);
}
//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void GalilSlit::always_executed_hook()
{
	
}
//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void GalilSlit::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "GalilSlit::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::read_gap
// 
// description : 	Extract real attribute values for gap acquisition result.
//
//-----------------------------------------------------------------------------
void GalilSlit::read_gap(Tango::Attribute &attr)
{
	DEBUG_STREAM << "GalilSlit::read_gap(Tango::Attribute &attr) entering... "<< endl;

  *attr_gap_read = this->m_slit->gap();
  *attr_gap_read += *attr_gapOffset_read;

  attr.set_value(attr_gap_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::write_gap
// 
// description : 	Write gap attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilSlit::write_gap(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "GalilSlit::write_gap(Tango::WAttribute &attr) entering... "<< endl;

  attr.get_write_value(attr_gap_write);

  this->m_slit->gap(attr_gap_write - *attr_gapOffset_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::read_position
// 
// description : 	Extract real attribute values for position acquisition result.
//
//-----------------------------------------------------------------------------
void GalilSlit::read_position(Tango::Attribute &attr)
{
	DEBUG_STREAM << "GalilSlit::read_position(Tango::Attribute &attr) entering... "<< endl;

  *attr_position_read = this->m_slit->position();
  *attr_position_read += *attr_positionOffset_read;

  attr.set_value(attr_position_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::write_position
// 
// description : 	Write position attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilSlit::write_position(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "GalilSlit::write_position(Tango::WAttribute &attr) entering... "<< endl;

  attr.get_write_value(attr_position_write);

  this->m_slit->position(attr_position_write - *attr_positionOffset_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::read_insideUpPosition
// 
// description : 	Extract real attribute values for insideUpPosition acquisition result.
//
//-----------------------------------------------------------------------------
void GalilSlit::read_insideUpPosition(Tango::Attribute &attr)
{
	DEBUG_STREAM << "GalilSlit::read_insideUpPosition(Tango::Attribute &attr) entering... "<< endl;

  *attr_insideUpPosition_read = this->m_slit->master_position();

  attr.set_value(attr_insideUpPosition_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::write_insideUpPosition
// 
// description : 	Write insideUpPosition attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilSlit::write_insideUpPosition(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "GalilSlit::write_insideUpPosition(Tango::WAttribute &attr) entering... "<< endl;

  attr.get_write_value(attr_insideUpPosition_write);

  this->m_slit->master_position(attr_insideUpPosition_write);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::read_outsideDownPosition
// 
// description : 	Extract real attribute values for outsideDownPosition acquisition result.
//
//-----------------------------------------------------------------------------
void GalilSlit::read_outsideDownPosition(Tango::Attribute &attr)
{
	DEBUG_STREAM << "GalilSlit::read_outsideDownPosition(Tango::Attribute &attr) entering... "<< endl;

  *attr_outsideDownPosition_read = this->m_slit->slave_position();

  attr.set_value(attr_outsideDownPosition_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::write_outsideDownPosition
// 
// description : 	Write outsideDownPosition attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilSlit::write_outsideDownPosition(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "GalilSlit::write_outsideDownPosition(Tango::WAttribute &attr) entering... "<< endl;

  attr.get_write_value(attr_outsideDownPosition_write);

  this->m_slit->slave_position(attr_outsideDownPosition_write);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::read_positionOffset
// 
// description : 	Extract real attribute values for positionOffset acquisition result.
//
//-----------------------------------------------------------------------------
void GalilSlit::read_positionOffset(Tango::Attribute &attr)
{
	DEBUG_STREAM << "GalilSlit::read_positionOffset(Tango::Attribute &attr) entering... "<< endl;
	
  attr.set_value(attr_positionOffset_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::write_positionOffset
// 
// description : 	Write positionOffset attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilSlit::write_positionOffset(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "GalilSlit::write_positionOffset(Tango::WAttribute &attr) entering... "<< endl;
	
  attr.get_write_value(*attr_positionOffset_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::read_gapOffset
// 
// description : 	Extract real attribute values for gapOffset acquisition result.
//
//-----------------------------------------------------------------------------
void GalilSlit::read_gapOffset(Tango::Attribute &attr)
{
	DEBUG_STREAM << "GalilSlit::read_gapOffset(Tango::Attribute &attr) entering... "<< endl;
	
  attr.set_value(attr_gapOffset_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilSlit::write_gapOffset
// 
// description : 	Write gapOffset attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilSlit::write_gapOffset(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "GalilSlit::write_gapOffset(Tango::WAttribute &attr) entering... "<< endl;
	
  attr.get_write_value(*attr_gapOffset_read);
}


//+------------------------------------------------------------------
/**
 *	method:	GalilSlit::stop
 *
 *	description:	method to execute "Stop"
 *	stops any movement on the slit
 *
 *
 */
//+------------------------------------------------------------------
void GalilSlit::stop()
{
	DEBUG_STREAM << "GalilSlit::stop(): entering... !" << endl;

	//	Add your own code to control device here

  this->m_slit->stop();
}

//+------------------------------------------------------------------
/**
 *	method:	GalilSlit::set_independant_mode
 *
 *	description:	method to execute "SetIndependantMode"
 *	For slits with independant motorized blades,allow motors to move independantly.
 *	To be called before moving motors with their respective GalilAxis Device Servers
 *
 *
 */
//+------------------------------------------------------------------
void GalilSlit::set_independant_mode()
{
	DEBUG_STREAM << "GalilSlit::set_independant_mode(): entering... !" << endl;

	//	Add your own code to control device here

  this->m_slit->disable_gearing();

}

//+------------------------------------------------------------------
/**
* method: GalilSlit::dev_state
*
* description:  method to execute "State"
* Command to read the device state.
* The method dev_state() override a DeviceImpl class virtual method.
*
* @return State Code
*
*/
//+------------------------------------------------------------------
Tango::DevState GalilSlit::dev_state()
{
  DEBUG_STREAM << "GalilSlit::dev_state(): entering... !" << endl;

  //  Add your own code to control device here
  Tango::DevState argout = DeviceImpl::dev_state();

	//- is device properly initialized?
	if (! m_init_device_done ||  m_properties_missing)
  {
		this->set_state(Tango::FAULT);
    return Tango::FAULT;
	}

  galil::AxisState slit_state = this->m_slit->state();

  switch (slit_state)
  {
    case galil::AXIS_OFF:
	    this->set_state(Tango::OFF);
      return Tango::OFF;
      break;
    case galil::AXIS_MOVING:
	    this->set_state(Tango::MOVING);
      return Tango::MOVING;
      break;
    case galil::AXIS_STANDBY:
	    this->set_state(Tango::STANDBY);
      return Tango::STANDBY;
      break;
    case galil::AXIS_ALARM:
	    this->set_state(Tango::ALARM);
      return Tango::ALARM;
      break;
    case galil::AXIS_ERROR:
	    this->set_state(Tango::FAULT);
      return Tango::FAULT;
      break;
    case galil::AXIS_CRTL_DISABLED:
	    this->set_state(Tango::DISABLE);
      return Tango::DISABLE;
      break;
    default:
      break;
  }

  this->set_state(Tango::UNKNOWN);

  return Tango::UNKNOWN;
}

//+------------------------------------------------------------------
/**
* method: GalilSlit::dev_status
*
* description:  method to execute "Status"
* Command to read the device status.
* The method dev_status() override a DeviceImpl class virtual method.
*
* @return Status descrition
*
*/
//+------------------------------------------------------------------
Tango::ConstDevString GalilSlit::dev_status()
{
  DEBUG_STREAM << "GalilSlit::dev_status(): entering... !" << endl;

  //  Add your own code to control device here
	if ( this->m_properties_missing ) 
	{
		return this->m_status_str.c_str();
	}

	if (! this->m_init_device_done )
	{
    return m_status_str.c_str();
	}
  // get current slit status
  galil::SlitStatus css;
  this->m_slit->status(css);

  this->m_status_str = "Master Axis status : \n" +
                       css.master_status.status  +
                       "\nSlave Axis Status :\n" + 
                       css.slave_status.status   + 
											 "\nCombined Slit Status :\n"+
											 css.slit_status ;

  return m_status_str.c_str();
}


//+------------------------------------------------------------------
/**
 *	method:	GalilSlit::off
 *
 *	description:	method to execute "Off"
 *	turns Off the 2 motors of the slit if allowed (not running,... same conditions as GalilAxis)
 *
 *
 */
//+------------------------------------------------------------------
void GalilSlit::off()
{
	DEBUG_STREAM << "GalilSlit::off(): entering... !" << endl;

	//	Add your own code to control device here
  this->m_slit->off ();

}

//+------------------------------------------------------------------
/**
 *	method:	GalilSlit::on
 *
 *	description:	method to execute "On"
 *	turns On the 2 motors if allowed (same conditions as GalilAxis)
 *
 *
 */
//+------------------------------------------------------------------
void GalilSlit::on()
{
	DEBUG_STREAM << "GalilSlit::on(): entering... !" << endl;

	//	Add your own code to control device here
  this->m_slit->on ();

}


//+------------------------------------------------------------------
/**
 *	method:	GalilSlit::compute_new_gap_offset
 *
 *	description:	method to execute "ComputeNewGapOffset"
 *	computes and sets the gap offset as you want to see it here and now
 *	eg you have a gap = 10 and offset = 0
 *	you want it to be 9
 *	it will set the gapOffset to -1 and you will see gap = 9
 *	acts only on gapOffset
 *	does not modify motors offsets
 *	
 *	
 *	
 *
 * @param	argin	the gap you want to have here and now
 *
 */
//+------------------------------------------------------------------
void GalilSlit::compute_new_gap_offset(Tango::DevDouble argin)
{
	DEBUG_STREAM << "GalilSlit::compute_new_gap_offset(): entering... !" << endl;

	//	Add your own code to control device here
  *attr_gapOffset_read = (argin - this->m_slit->gap());


}

//+------------------------------------------------------------------
/**
 *	method:	GalilSlit::compute_new_position_offset
 *
 *	description:	method to execute "ComputeNewPositionOffset"
 *	computes and sets the position offset as you want to see it here and now
 *	eg you have a position = 10 and offset = 0
 *	you want it to be 9
 *	it will set the positionOffset to -1 and you will see position = 9
 *	acts only on positionOffset
 *	does not modify motors offsets
 *	
 *	
 *	
 *
 * @param	argin	the position you want to have here and now
 *
 */
//+------------------------------------------------------------------
void GalilSlit::compute_new_position_offset(Tango::DevDouble argin)
{
	DEBUG_STREAM << "GalilSlit::compute_new_position_offset(): entering... !" << endl;

	//	Add your own code to control device here
  *attr_positionOffset_read = (argin - this->m_slit->position());

}

}	//	namespace
