static const char *RcsId = "$Header: /usr/local/CVS/DeviceServer/Generic/Motorisation/ControlBoxV2/src/AxisRawDataReader.cpp,v 1.21 2011/07/15 09:47:42 buteau Exp $";
//+=============================================================================
//
// file :         AxisRawDataReader.cpp
//
// description :  C++ source for the AxisRawDataReader and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                AxisRawDataReader are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: buteau $
//
// $Revision: 1.21 $
//
// $Log: AxisRawDataReader.cpp,v $
// Revision 1.21  2011/07/15 09:47:42  buteau
// MANTIS 19368
//
// Revision 1.20  2011/07/15 09:40:53  buteau
// MANTIS 19368
//
// Revision 1.19  2011/05/27 13:45:28  coquet
// added attribute positionError to AxisRawDataDeader
// TO BE TESTED
//
// Revision 1.18  2011/05/19 10:52:44  coquet
// some include path updated
// changes yat dependency order
//
// Revision 1.17  2010/03/26 09:17:39  maven
// "Migration_Tango7_Part2"
//
// Revision 1.16  2010/01/29 16:35:17  coquet
// State now returns to ON when communications resumes after failure
//
// Revision 1.15  2008/10/20 13:23:55  coquet
// bug correction on AxisRawDataReader
//
// Revision 1.14  2008/10/17 07:06:15  coquet
// added attribute velocity to AxosRawDataReader
// to be tested
//
// Revision 1.13  2008/09/25 14:29:11  coquet
// Attribute AxisNumber is now memorized Write on Hardware at Init
// (was simply memorized before)
//
// Revision 1.12  2007/11/30 13:54:42  coquet
// bug correction on AxisRawDataReder command ReportLatchedPosition
// now it works
//
// Revision 1.11  2007/06/07 15:13:16  leclercq
// Tmp commit
//
// Revision 1.10  2007/06/07 10:23:15  leclercq
// Switched to yat::ClientSocket
//
// Revision 1.9  2007/06/05 15:29:22  leclercq
// Changed RawDataReader impl (no more axis - use shrared HwIO instead)
//
// Revision 1.8  2007/06/04 12:28:57  coquet
// AxisRawDataReader :
// added latch encoder position support
// added 2 attributes
// latchIsArmed, RO, bool, reports that latch feature is ready to capture encoder position
// latchOccured reports that latch occured since last latch arming
// added 2 commands
// ArmLatch arms the latch feature
// ReportLatchedPosition returns the last lached position ( exception if latch did not occured)
//
// Revision 1.7  2007/04/19 08:26:23  coquet
// AxisRawDataReader :
// added 3 attributes
// * axisLetter
// * latchInput
// * homeInput
// GalilSSlit :
// * added tips in Status to come out of Limit switchs if necessary
// * added boolean property InvertPositionDirection to allow user to invert the positive direction if necessary
// GalilAxis :
// * attribute position is in ALARM if positionning failed
// * internal "EncoderMotorRatio" is set to 1.0 when motor is servo (according to bit 0 of Stat[x])  or if stepper motor has no encoder.
//
// Revision 1.6  2007/04/06 13:46:20  leclercq
// Added com. health monitoring
// Refactoring of the HwIO internal state
//
// Revision 1.5  2007/01/15 13:16:46  leclercq
// Minor changes
//
// Revision 1.4  2007/01/11 08:42:36  coquet
// AxisRawDataReader device first tests :
// apply correct ratio to analog value readback
//
// Revision 1.3  2007/01/08 15:35:58  leclercq
// Small changes in Makefile.linux
//
// Revision 1.2  2007/01/08 14:45:18  coquet
// AxisRawDataReader device first tests :
// bug corrections.
//
// Revision 1.1  2007/01/08 11:19:54  coquet
// added AxisRawDataReader device
// this devices offers read-only acces to raw data of an axis (selected by an attribute)
// added the files AxisRawDataReader*.*,
// modified ClassFactory, Makefile.vc, DevicesGalilV2.dsp Visual Studio project
//
//
// copyleft :  Synchrotron SOLEIL
//             L'Orme des Merisiers
//             Saint-Aubin - BP 48
//             FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name           |  Method name
//	----------------------------------------
//  State                  |  dev_state()
//  Status                 |  dev_status()
//  ReportLatchedPosition  |  report_latched_position()
//  ArmLatch               |  arm_latch()
//
//===================================================================


#include <tango.h>
#include <AxisRawDataReader.h>
#include <AxisRawDataReaderClass.h>
//- galil support stuffs
#include <ObjectManager.h>
#include <Box.h>
#include <Axis.h>
#include <HwIO.h>
//- yat stuffs
#include <yat/utils/XString.h>
#include <PogoHelper.h>

namespace AxisRawDataReader_ns
{

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::AxisRawDataReader(string &s)
// 
// description : 	constructor for simulated AxisRawDataReader
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
AxisRawDataReader::AxisRawDataReader(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

AxisRawDataReader::AxisRawDataReader(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
	init_device();
}

AxisRawDataReader::AxisRawDataReader(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::delete_device()
{
	//	Delete device's allocated object
	DEBUG_STREAM << " AxisRawDataReader::delete_device() " << std::endl;

	//	Delete device's allocated object
	DELETE_SCALAR_ATTRIBUTE(attr_axisNumber_read);
	DELETE_SCALAR_ATTRIBUTE(attr_encoder_read);
	DELETE_SCALAR_ATTRIBUTE(attr_auxiliary_read);
	DELETE_SCALAR_ATTRIBUTE(attr_velocity_read);
	DELETE_SCALAR_ATTRIBUTE(attr_commandedPos_read);
	DELETE_SCALAR_ATTRIBUTE(attr_analogInput_read);
	DELETE_SCALAR_ATTRIBUTE(attr_homeInput_read);
	DELETE_SCALAR_ATTRIBUTE(attr_latchInput_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_axisLetter_read);
	DELETE_SCALAR_ATTRIBUTE(attr_latchOccured_read);
	DELETE_SCALAR_ATTRIBUTE(attr_latchIsArmed_read);
	DELETE_SCALAR_ATTRIBUTE(attr_positionError_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::init_device()
{
	INFO_STREAM << "AxisRawDataReader::AxisRawDataReader() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------

	//	Create device's allocated object
	m_axis_id = galil::AXIS_A;
	attr_axisNumber_write = 0;

	//- reset init flag
	this->m_init_device_done = false;

	try
	{
		CREATE_SCALAR_ATTRIBUTE(attr_axisNumber_read);
		CREATE_SCALAR_ATTRIBUTE(attr_encoder_read);
		CREATE_SCALAR_ATTRIBUTE(attr_auxiliary_read);
		CREATE_SCALAR_ATTRIBUTE(attr_velocity_read);
		CREATE_SCALAR_ATTRIBUTE(attr_commandedPos_read);
		CREATE_SCALAR_ATTRIBUTE(attr_analogInput_read);
		CREATE_SCALAR_ATTRIBUTE(attr_homeInput_read);
		CREATE_SCALAR_ATTRIBUTE(attr_latchInput_read);
		CREATE_DEVSTRING_ATTRIBUTE(attr_axisLetter_read,2);
		CREATE_SCALAR_ATTRIBUTE(attr_latchOccured_read);
		CREATE_SCALAR_ATTRIBUTE(attr_latchIsArmed_read);
	  CREATE_SCALAR_ATTRIBUTE(attr_positionError_read);
	}
	catch(...)
	{
		set_state(Tango::FAULT);
		set_status("device initialization failed [attributes instanciation failed]");
		return;
	}

  this->m_init_device_done = true;
	this->set_state(Tango::ON);
	this->set_status("device up and ready");
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::always_executed_hook()
{

}
//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "AxisRawDataReader::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
	
  try
	{
	  HW_STATUS_PROXY->firmware_axis_state(m_axis_id, m_fas);
		this->set_state(Tango::ON);
		this->set_status("device is un and ready");
	}
	catch(Tango::DevFailed &)
	{
		this->set_state(Tango::FAULT);
		this->set_status("communication failure [check ControlBox status for details]");
		throw;
	}
	catch(...)
	{
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("unknown exception caught"),
                    _CPTC("AxisRawDataReader::read_attr_hardware"));
	}
}
//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_positionError
// 
// description : 	Extract real attribute values for positionError acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_positionError(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_positionError(Tango::Attribute &attr) entering... "<< endl;
	*attr_positionError_read = static_cast<Tango::DevLong>(m_fas.pos_err());
	attr.set_value(attr_positionError_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_velocity
// 
// description : 	Extract real attribute values for velocity acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_velocity(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_velocity(Tango::Attribute &attr) entering... "<< endl;
	*attr_velocity_read = static_cast<Tango::DevLong>(m_fas.velocity());
	attr.set_value(attr_velocity_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_latchOccured
// 
// description : 	Extract real attribute values for latchOccured acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_latchOccured(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_latchOccured(Tango::Attribute &attr) entering... "<< endl;
	*attr_latchOccured_read = m_fas.latch_occured();
	attr.set_value(attr_latchOccured_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_latchIsArmed
// 
// description : 	Extract real attribute values for latchIsArmed acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_latchIsArmed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_latchIsArmed(Tango::Attribute &attr) entering... "<< endl;
	*attr_latchIsArmed_read = m_fas.latch_armed();
	attr.set_value(attr_latchIsArmed_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_axisLetter
// 
// description : 	Extract real attribute values for axisLetter acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_axisLetter(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_axisLetter(Tango::Attribute &attr) entering... "<< endl;
	switch(m_axis_id)
	{
		case galil::AXIS_A:
			attr_axisLetter_read[0] = "A";
			break;
		case galil::AXIS_B:
			attr_axisLetter_read[0] = "B";
			break;
		case galil::AXIS_C:
			attr_axisLetter_read[0] = "C";
			break;
		case galil::AXIS_D:
			attr_axisLetter_read[0] = "D";
			break;
#if !defined(DMC_4143)
		case galil::AXIS_E:
			attr_axisLetter_read[0] = "E";
			break;
		case galil::AXIS_F:
			attr_axisLetter_read[0] = "F";
			break;
		case galil::AXIS_G:
			attr_axisLetter_read[0] = "G";
			break;
		case galil::AXIS_H:
			attr_axisLetter_read[0] = "H";
			break;
#endif
		default:
      THROW_DEVFAILED(_CPTC("INTERNAL_ERROR"),
                      _CPTC("unexpected axis identifier"),
                      _CPTC("AxisRawDataReader::read_axisLetter"));
			break; 
	}
	attr.set_value(attr_axisLetter_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_homeInput
// 
// description : 	Extract real attribute values for homeInput acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_homeInput(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_homeInput(Tango::Attribute &attr) entering... "<< endl;
	*attr_homeInput_read = m_fas.home_sw();
	attr.set_value(attr_homeInput_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_latchInput
// 
// description : 	Extract real attribute values for latchInput acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_latchInput(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_latchInput(Tango::Attribute &attr) entering... "<< endl;
	*attr_latchInput_read = m_fas.latch_state();
	attr.set_value(attr_latchInput_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_axisNumber
// 
// description : 	Extract real attribute values for axisNumber acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_axisNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_axisNumber(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(&attr_axisNumber_write);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::write_axisNumber
// 
// description : 	Write axisNumber attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::write_axisNumber(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::write_axisNumber(Tango::WAttribute &attr) entering... "<< endl;
	attr.get_write_value(attr_axisNumber_write);
	switch (attr_axisNumber_write)
	{
		case 0:
			m_axis_id = galil::AXIS_A;
			break;
		case 1:
			m_axis_id = galil::AXIS_B;
			break;
		case 2:
			m_axis_id = galil::AXIS_C;
			break;
		case 3:
			m_axis_id = galil::AXIS_D;
			break;
#if !defined(DMC_4143)
		case 4:
			m_axis_id = galil::AXIS_E;
			break;
		case 5:
			m_axis_id = galil::AXIS_F;
			break;
		case 6:
			m_axis_id = galil::AXIS_G;
			break;
		case 7:
			m_axis_id = galil::AXIS_H;
			break;
#endif
		default:
			m_axis_id = galil::AXIS_A;
			attr_axisNumber_write = 0;
			set_state(Tango::FAULT);
			set_status("invalid axis identifier specified - must be in [0..7] for axis A to H");
			THROW_DEVFAILED(_CPTC("OUT_OF_RANGE"),
											_CPTC("invalid axis identifier specified - number out of range - must be in [0..7]"),
											_CPTC("AxisRawDataReader::write_axisNumber"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_encoder
// 
// description : 	Extract real attribute values for encoder acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_encoder(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_encoder(Tango::Attribute &attr) entering... "<< endl;
	*attr_encoder_read = static_cast<Tango::DevLong>(m_fas.mot_pos());
	attr.set_value(attr_encoder_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_auxiliary
// 
// description : 	Extract real attribute values for auxiliary acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_auxiliary(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_auxiliary(Tango::Attribute &attr) entering... "<< endl;
	*attr_auxiliary_read = static_cast<Tango::DevLong>(m_fas.aux_pos());
	attr.set_value(attr_auxiliary_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_commandedPos
// 
// description : 	Extract real attribute values for commandedPos acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_commandedPos(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_commandedPos(Tango::Attribute &attr) entering... "<< endl;
	*attr_commandedPos_read = static_cast<Tango::DevLong>(m_fas.ref_pos());
	attr.set_value(attr_commandedPos_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AxisRawDataReader::read_analogInput
// 
// description : 	Extract real attribute values for analogInput acquisition result.
//
//-----------------------------------------------------------------------------
void AxisRawDataReader::read_analogInput(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AxisRawDataReader::read_analogInput(Tango::Attribute &attr) entering... "<< endl;
	*attr_analogInput_read = static_cast<double>(m_fas.ana_in());
	// ana_in is a 16-bit value, -10.0v = -32768, +10.0v = 32767 apply ratio
	*attr_analogInput_read *= 0.00030517578125;
	attr.set_value(attr_analogInput_read);
}

//+------------------------------------------------------------------
/**
 *	method:	AxisRawDataReader::report_latched_position
 *
 *	description:	method to execute "ReportLatchedPosition"
 *	returns the last latched encoder position
 *	exception thrown if there is no latched position
 *
 * @return	the encoder value latched
 *
 */
//+------------------------------------------------------------------
Tango::DevLong AxisRawDataReader::report_latched_position()
{
	DEBUG_STREAM << "AxisRawDataReader::report_latched_position(): entering... !" << endl;

	//- is latch armed?
	//- when latch occurs, bit latch is armed falls?
/*	if (! m_fas.latch_armed())
	{
    THROW_DEVFAILED(_CPTC("OPERATION_NOT_ALLOWED"),
                    _CPTC("lacth is not armed [arm lacth first]"),
                    _CPTC("AxisRawDataReader::report_latched_position"));
  }*/

	//- did latch occured?
	if (! m_fas.latch_occured())
	{
    THROW_DEVFAILED(_CPTC("OPERATION_NOT_ALLOWED"),
                    _CPTC("no lacthed position available [latch event did not occured]"),
                    _CPTC("AxisRawDataReader::report_latched_position"));
  }

  long latched_pos = 0;
  
  try
  {
    //- get latched pos
    yat::OSStream cmd;
    cmd << "MG _RL"
        << galil::Axis::axis_id_to_string(m_axis_id)
        << "\r";
        
    std::string latched_pos_str;
    
    SHARED_HW_IO->inout(cmd.str(), latched_pos_str);
    
    latched_pos = yat::XString<long>::to_num(latched_pos_str);
  }
  catch (Tango::DevFailed& df)
  {
    RETHROW_DEVFAILED(df,
                      _CPTC("COMMUNICATION_ERROR"),
                      _CPTC("could not obtain latched position [communication error]"),
                      _CPTC("AxisRawDataReader::report_latched_position"));
  }
  catch (...)
  {
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("could not obtain latched position [unknown exception caught]"),
                    _CPTC("AxisRawDataReader::report_latched_position"));
  }
  
  return latched_pos;
}

//+------------------------------------------------------------------
/**
 *	method:	AxisRawDataReader::arm_latch
 *
 *	description:	method to execute "ArmLatch"
 *	arms the latch function to capture the encoder position on edge of latch input
 *
 *
 */
//+------------------------------------------------------------------
void AxisRawDataReader::arm_latch()
{
	DEBUG_STREAM << "AxisRawDataReader::arm_latch(): entering... !" << endl;

	//	Add your own code to control device here

  try
  {
    yat::OSStream cmd;
    cmd << "AL"
        << galil::Axis::axis_id_to_string(m_axis_id)
        << "\r";
    SHARED_HW_IO->in(cmd.str(), galil::IOCheckError);
  }
  catch (Tango::DevFailed & df)
  {
    RETHROW_DEVFAILED(df,
                      _CPTC("COMMUNICATION_ERROR"),
                      _CPTC("could not arm latch [Tango exception caught]"),
                      _CPTC("AxisRawDataReader::arm_latch"));
  }
  catch (...)
  {
    THROW_DEVFAILED(_CPTC("UNKNOWN_ERROR"),
                    _CPTC("could not arm latch [unknown exception caught]"),
                    _CPTC("AxisRawDataReader::arm_latch"));
  }
}



}	//	namespace
