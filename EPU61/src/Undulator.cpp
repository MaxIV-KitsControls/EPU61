/*----- PROTECTED REGION ID(Undulator.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        Undulator.cpp
//
// description : C++ source for the Undulator and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Undulator are implemented in this file.
//
// project :     .
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL:  $
//
// CVS only:
// $Source:  $
// $Log:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <Undulator.h>
#include <UndulatorClass.h>
#include <cmath>
#include "insertion/UpdaterThread.h"
#include "correction/PollerThread.h"

#define VECTOR_UNIT_TO_INDIVIDUAL 1.414213562 //!< Converts vector speed/acceleration into axis speed/acceleration for phase (2 axes in movement)

/*----- PROTECTED REGION END -----*/


/**
 *	Undulator class description:
 *	Device server for controling movement of undulator axes. 
 *	It features gap movement and phase movement in 4 modes.
 *	In expert mode, user can configure the behaviour of axes and restrict certain actions.
 */

//================================================================
//
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name        |  Method name
//----------------------------------------------------------------
//  State               |  Inherited (no method)
//  Status              |  Inherited (no method)
//  StopGap             |  stop_gap
//  ToggleStopAll       |  toggle_stop_all
//  DisableLimits       |  disable_limits
//  StopPhase           |  stop_phase
//  CalibrateGap        |  calibrate_gap
//  CalibratePhase      |  calibrate_phase
//  LoadCorrectionData  |  load_correction_data
//================================================================

namespace Undulator_ns
{
	/*----- PROTECTED REGION ID(Undulator::namespace_starting) ENABLED START -----*/





	/*----- PROTECTED REGION END -----*/	//	Undulator::namespace_starting



//--------------------------------------------------------
/**
 *	Method      : Undulator::Undulator()
 *	Description : Constructors for a Tango device
 *	              implementing the class Undulator
 */
//--------------------------------------------------------
Undulator::Undulator(Tango::DeviceClass *cl, string &s)
 	: Tango::Device_4Impl(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(Undulator::constructor_1) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Undulator::constructor_1
}
//--------------------------------------------------------
Undulator::Undulator(Tango::DeviceClass *cl, const char *s)
 	: Tango::Device_4Impl(cl, s)
{
	/*----- PROTECTED REGION ID(Undulator::constructor_2) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Undulator::constructor_2
}
//--------------------------------------------------------
Undulator::Undulator(Tango::DeviceClass *cl, const char *s, const char *d)
 	: Tango::Device_4Impl(cl, s, d)
{
	/*----- PROTECTED REGION ID(Undulator::constructor_3) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Undulator::constructor_3
}


//--------------------------------------------------------
/**
 *	Method      : Undulator::delete_device()()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Undulator::delete_device()
{
	/*----- PROTECTED REGION ID(Undulator::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	if (stateUpdater)
	{
		stateUpdater->abort();
		stateUpdater->join(0);
		stateUpdater = 0;
	}

	if (pollerThread)
	{
	    pollerThread->abort();
	    pollerThread->join(0);
	    pollerThread = 0;
	}

	if (supplies)
    {
	    supplies->abort();
	    supplies->join(0);
	    supplies = 0;
    }

    if (galilFunctions) delete galilFunctions;
    if (phaseAxesGroup) delete phaseAxesGroup;
    if (gapAxesGroup) delete gapAxesGroup;

	/*----- PROTECTED REGION END -----*/	//	Undulator::delete_device
	
}


//--------------------------------------------------------
/**
 *	Method      : Undulator::init_device()
 *	Description : //	will be called at device initialization.
 */
//--------------------------------------------------------
void Undulator::init_device()
{
	DEBUG_STREAM << "Undulator::init_device() create device " << device_name << endl;

	/*----- PROTECTED REGION ID(Undulator::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call

	/*----- PROTECTED REGION END -----*/	//	Undulator::init_device_before
	
	//	Get the device properties (if any) from database
	get_device_property();
	
	
	/*----- PROTECTED REGION ID(Undulator::init_device) ENABLED START -----*/

	// Initialize pointers to null
	stateUpdater = 0;
	pollerThread = 0;
	phaseAxesGroup = gapAxesGroup = 0;
	galilFunctions = 0;

	// Initialize device
	// Variables to 0.
	gap = 0;
	taper = 0;
	center = 0;
	phaseOffset = 0;

	minGap = 0;
	maxGap = 0;
	maxOpPhase = 0;
	desiredGap = 0;
	desiredOffset = 0;
	desiredCenter = 0;
	desiredTaper = 0;

	interlock = false;

	phaseMoving = false;
	gapMoving = false;
	stopAll = false;
	limitsDisabled = false;
	engineeringLock = false;
	coilCorrectionEnabled = false;

	// Initialize desired current to 0
	for(int i = 0; i < 4; i++)
	    desiredCurrent.push_back(0);

	try
	{
	    // Create groups.
	    phaseAxesGroup = new Tango::Group("");
	    gapAxesGroup = new Tango::Group("");

	    if(gapAxes.size() != phaseAxes.size())
	        Tango::Except::throw_exception("Number of gap and phase axes doesn't match.",
	                    "Number of proxys for gap and phase in properties is not the same.","init_device()", Tango::ERR);

	    for(uint i = 0; i < gapAxes.size(); i++)
	    {
	        phaseAxesGroup->add(phaseAxes[i]);
	        gapAxesGroup->add(gapAxes[i]);
	    }

	    galilFunctions = new GalilCommunicator(controlBoxGapProxy, controlBoxPhaseProxy);

	    // Read counts to micrometer ratio.
	    Tango::DbData deviceProperty;
	    string propertyName = "AxisPositionRatio";

	    // Read from first gap axis since all should be the same.
	    Tango::DeviceProxy(gapAxes[0]).get_property(propertyName , deviceProperty);
	    deviceProperty[0] >> positionRatioGap;

	    // Same for phase axis.
	    Tango::DeviceProxy(phaseAxes[0]).get_property(propertyName , deviceProperty);
	    deviceProperty[0] >> positionRatioPhase;

	    // Set tango state to ON.
	    this->set_state(Tango::ON);

	    supplies = new PowerSupplyThread(powerSupplyProxy, powerSupplyAttributeNames);
	    supplies->go();

	    // Start thread for state and position updates.
	    stateUpdater = new UpdaterThread(*this, 1000, gapAxes, phaseAxes, gearedAxes);
	    stateUpdater->go();


	    pollerThread = new PollerThread(*this, controlBoxGapProxy, controlBoxPhaseProxy);
	    pollerThread->go();


	}
	catch(Tango::DevFailed& err)
	{
	    this->set_state(Tango::FAULT);
	    stringstream msg;
	    msg << "Tango exception in initialization." << endl
	            << "Reason: " << err.errors[0].reason << endl
	            << "Description: " << err.errors[0].desc;
	    cout << msg.str() << endl;
	}
	catch(std::exception& err)
	{
	    this->set_state(Tango::FAULT);
	    cout << err.what() << endl;
	}
	catch(...)
	{
	    this->set_state(Tango::FAULT);
	    cout << "Unknown exception occurred in initialization." << endl;
	}

	// Try to load the interpolation data table from the provided DataFile property
    try
    {
        if(this->state() != Tango::FAULT)
            load_correction_data(const_cast<char*>(dataFile.c_str()));
    }
    catch (...)
    {
        WARN_STREAM << "Couldn't load data file from property." << endl;
    }


	/*----- PROTECTED REGION END -----*/	//	Undulator::init_device
}



//--------------------------------------------------------
/**
 *	Method      : Undulator::get_device_property()
 *	Description : //	Add your own code to initialize
 */
//--------------------------------------------------------
void Undulator::get_device_property()
{
	/*----- PROTECTED REGION ID(Undulator::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	Undulator::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("ControlBoxGapProxy"));
	dev_prop.push_back(Tango::DbDatum("GapAxes"));
	dev_prop.push_back(Tango::DbDatum("PhaseAxes"));
	dev_prop.push_back(Tango::DbDatum("ControlBoxPhaseProxy"));
	dev_prop.push_back(Tango::DbDatum("GearedAxes"));
	dev_prop.push_back(Tango::DbDatum("DataFile"));
	dev_prop.push_back(Tango::DbDatum("PowerSupplyProxy"));
	dev_prop.push_back(Tango::DbDatum("PowerSupplyAttributeNames"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on UndulatorClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		UndulatorClass	*ds_class =
			(static_cast<UndulatorClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize ControlBoxGapProxy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  controlBoxGapProxy;
		else {
			//	Try to initialize ControlBoxGapProxy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  controlBoxGapProxy;
		}
		//	And try to extract ControlBoxGapProxy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  controlBoxGapProxy;

		//	Try to initialize GapAxes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gapAxes;
		else {
			//	Try to initialize GapAxes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gapAxes;
		}
		//	And try to extract GapAxes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gapAxes;

		//	Try to initialize PhaseAxes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  phaseAxes;
		else {
			//	Try to initialize PhaseAxes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  phaseAxes;
		}
		//	And try to extract PhaseAxes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  phaseAxes;

		//	Try to initialize ControlBoxPhaseProxy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  controlBoxPhaseProxy;
		else {
			//	Try to initialize ControlBoxPhaseProxy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  controlBoxPhaseProxy;
		}
		//	And try to extract ControlBoxPhaseProxy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  controlBoxPhaseProxy;

		//	Try to initialize GearedAxes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gearedAxes;
		else {
			//	Try to initialize GearedAxes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gearedAxes;
		}
		//	And try to extract GearedAxes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gearedAxes;

		//	Try to initialize DataFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dataFile;
		else {
			//	Try to initialize DataFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dataFile;
		}
		//	And try to extract DataFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dataFile;

		//	Try to initialize PowerSupplyProxy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  powerSupplyProxy;
		else {
			//	Try to initialize PowerSupplyProxy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  powerSupplyProxy;
		}
		//	And try to extract PowerSupplyProxy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  powerSupplyProxy;

		//	Try to initialize PowerSupplyAttributeNames from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  powerSupplyAttributeNames;
		else {
			//	Try to initialize PowerSupplyAttributeNames from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  powerSupplyAttributeNames;
		}
		//	And try to extract PowerSupplyAttributeNames value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  powerSupplyAttributeNames;


	}
	/*----- PROTECTED REGION ID(Undulator::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	Undulator::get_device_property_after

}

//--------------------------------------------------------
/**
 *	Method      : Undulator::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void Undulator::always_executed_hook()
{
	INFO_STREAM << "Undulator::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::always_executed_hook) ENABLED START -----*/


	/*----- PROTECTED REGION END -----*/	//	Undulator::always_executed_hook
}



//--------------------------------------------------------
/**
 *	Method      : Undulator::read_attr_hardware()
 *	Description : Hardware acquisition for attributes.
 */
//--------------------------------------------------------
void Undulator::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "Undulator::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_attr_hardware) ENABLED START -----*/



	/*----- PROTECTED REGION END -----*/	//	Undulator::read_attr_hardware

}


//--------------------------------------------------------
/**
 *	Read Gap attribute
 *	Description: Read-back and set-point for current gap. 
 *	             Writing to this attribute commences movement for the gap, 
 *	             using the current operator center offset and taper.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Gap(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Gap(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Gap) ENABLED START -----*/

	// Read max phase offset value from properties.
    Tango::AttributeConfig confGap;
    attr.get_properties(confGap);

    // Convert string to double.
    double max = atof(confGap.max_value);
    double min = atof(confGap.min_value);

    // If new maximum/minimum set, update them and recalculate new limits.
    if((max != maxGap) || (min != minGap))
    {
	    maxGap = max;
	    minGap = min;
	    if (!limitsDisabled)
	        set_soft_limits_gap();
    }

    omni_mutex_lock guard(deviceLock);
    attr.set_value(&gap);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Gap
}

//--------------------------------------------------------
/**
 *	Write Gap attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Gap(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Gap(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Gap) ENABLED START -----*/

	desiredGap = w_val;
    start_gap();

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Gap
}

//--------------------------------------------------------
/**
 *	Read EngineeringLock attribute
 *	Description: Setting this attribute to TRUE disables operator composite movements. 
 *	             Engineering movements to be done directly on the ControlBox axis devices.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringLock(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringLock(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringLock) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&engineeringLock);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringLock
}

//--------------------------------------------------------
/**
 *	Write EngineeringLock attribute values to hardware.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringLock(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringLock(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringLock) ENABLED START -----*/

	engineeringLock = static_cast<bool>(w_val);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringLock
}

//--------------------------------------------------------
/**
 *	Read GapAcceleration attribute
 *	Description: Gap movement average acceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapAcceleration) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&gapAcc);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapAcceleration
}

//--------------------------------------------------------
/**
 *	Write GapAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_GapAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_GapAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_GapAcceleration) ENABLED START -----*/

	gapAcc = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_GapAcceleration
}

//--------------------------------------------------------
/**
 *	Read GapSpeed attribute
 *	Description: Final profile velocity in um/s for gap movements.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapSpeed) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&gapSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapSpeed
}

//--------------------------------------------------------
/**
 *	Write GapSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_GapSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_GapSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_GapSpeed) ENABLED START -----*/

    gapSpeed = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_GapSpeed
}

//--------------------------------------------------------
/**
 *	Read PhaseAcceleration attribute
 *	Description: Phase movement average acceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseAcceleration) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&phaseAcc);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Write PhaseAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_PhaseAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_PhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_PhaseAcceleration) ENABLED START -----*/

	phaseAcc = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_PhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Read PhaseMode attribute
 *	Description: Read-back and set-point for desired phase mode. 
 *	             Will be used next time Phase is written.
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseMode(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseMode) ENABLED START -----*/

	// Get the current phase mode from DMC.
    short value = galilFunctions->get_phaseMode();

    {
        omni_mutex_lock guard(deviceLock);
        phase = value;
    }
	//	Set the attribute value
	attr.set_value(&phase);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseMode
}

//--------------------------------------------------------
/**
 *	Write PhaseMode attribute values to hardware.
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_PhaseMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_PhaseMode(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevShort	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_PhaseMode) ENABLED START -----*/

	desiredPhase = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_PhaseMode
}

//--------------------------------------------------------
/**
 *	Read Phase attribute
 *	Description: Read-back and set-point for phase offset.
 *	             When this attribute is written new phase movement commences 
 *	             using phase mode specified in PhaseMode attribute.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Phase(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Phase(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Phase) ENABLED START -----*/

	// Read max phase offset value from properties.
	Tango::AttributeConfig confPhase;
	attr.get_properties(confPhase);
	// Convert string to double.
	double max = atof(confPhase.max_value);
	// If new maximum set, update it and recalculate new limits.
	if(max != maxOpPhase)
	{
	    maxOpPhase = max;
	    if (!limitsDisabled)
	        set_soft_limits_phase();
	}

	omni_mutex_lock guard(deviceLock);
	attr.set_value(&phaseOffset);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Phase
}

//--------------------------------------------------------
/**
 *	Write Phase attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Phase(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Phase(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Phase) ENABLED START -----*/
	
	desiredOffset = w_val;
    start_phase();


	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Phase
}

//--------------------------------------------------------
/**
 *	Read PhaseSpeed attribute
 *	Description: Final profile velocity in um/s for phase (sub-girders) movement.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseSpeed) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&phaseSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseSpeed
}

//--------------------------------------------------------
/**
 *	Write PhaseSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_PhaseSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_PhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_PhaseSpeed) ENABLED START -----*/

	phaseSpeed = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_PhaseSpeed
}

//--------------------------------------------------------
/**
 *	Read TaperAcceleration attribute
 *	Description: Taper movement average acceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_TaperAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_TaperAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_TaperAcceleration) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&taperAcc);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_TaperAcceleration
}

//--------------------------------------------------------
/**
 *	Write TaperAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_TaperAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_TaperAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_TaperAcceleration) ENABLED START -----*/

	taperAcc = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_TaperAcceleration
}

//--------------------------------------------------------
/**
 *	Read Taper attribute
 *	Description: Read-back and set-point value for the current taper. 
 *	             Will be applied next time the GapSetpoint attribute is modified.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Taper(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Taper(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Taper) ENABLED START -----*/

	omni_mutex_lock guard(deviceLock);
	attr.set_value(&taper);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Taper
}

//--------------------------------------------------------
/**
 *	Write Taper attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Taper(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Taper(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Taper) ENABLED START -----*/

	desiredTaper = w_val;

    // Taper changed, set new gap limits.
    if (!limitsDisabled)
	    set_soft_limits_gap();

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Taper
}

//--------------------------------------------------------
/**
 *	Read Offset attribute
 *	Description: Read-back and set-point value for the current vertical offset. 
 *	             Will be applied next time the Gap attribute is modified.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Offset(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Offset(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Offset) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&center);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Offset
}

//--------------------------------------------------------
/**
 *	Write Offset attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Offset(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Offset(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Offset) ENABLED START -----*/

	desiredCenter = w_val;

	// Center changed, set new gap limits.
	if (!limitsDisabled)
	    set_soft_limits_gap();

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Offset
}

//--------------------------------------------------------
/**
 *	Read TaperSpeed attribute
 *	Description: Final profile velocity in um/s for taper movements.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_TaperSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_TaperSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_TaperSpeed) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&taperSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_TaperSpeed
}

//--------------------------------------------------------
/**
 *	Write TaperSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_TaperSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_TaperSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_TaperSpeed) ENABLED START -----*/

	taperSpeed = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_TaperSpeed
}

//--------------------------------------------------------
/**
 *	Read LimitsDisabled attribute
 *	Description: Indicates that the software limits on the DMCs are disabled. 
 *	             Useful for commissioning and engineering movements.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_LimitsDisabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_LimitsDisabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_LimitsDisabled) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&limitsDisabled);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_LimitsDisabled
}
//--------------------------------------------------------
/**
 *	Read StopAll attribute
 *	Description: Indicates that the undulator is in StopAll state inhibiting all motion.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_StopAll(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_StopAll(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_StopAll) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&stopAll);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_StopAll
}
//--------------------------------------------------------
/**
 *	Read GapMoving attribute
 *	Description: Indicates that gap movement is in progress. 
 *	             Used to distinguish whether gap, phase or both are moving.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapMoving(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapMoving(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapMoving) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&gapMoving);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapMoving
}
//--------------------------------------------------------
/**
 *	Read PhaseMoving attribute
 *	Description: Indicates that phase movement is in progress. 
 *	             Used to distinguish whether gap, phase or both are moving.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseMoving(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseMoving(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseMoving) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&phaseMoving);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseMoving
}
//--------------------------------------------------------
/**
 *	Read EngineeringGapSpeed attribute
 *	Description: Final profile velocity in um/s for gap axes engineering movement.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringGapSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringGapSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringGapSpeed) ENABLED START -----*/

	// Get values.
	Tango::GroupAttrReplyList replyList = gapAxesGroup->read_attribute("velocity", false);

	// Check if read failed.
    if(replyList.has_failed())
    {
	    ERROR_STREAM << "Error reading engineering gap speed." << endl;
	    attr.set_quality(Tango::ATTR_INVALID);
    }
    else
    {
        double tempSpeed;

        // Extract first velocity.
        replyList[0] >> engineeringGapAxesSpeed;

        for(uint i = 1; i < replyList.size(); i++)
        {
            // Extract others and compare. If all are the same show speed otherwise show zero.
            replyList[i] >> tempSpeed;
            if(engineeringGapAxesSpeed != tempSpeed)
            {
                engineeringGapAxesSpeed = 0;
                break;
            }
        }
        attr.set_quality(Tango::ATTR_VALID);
    }
    //  Set the attribute value
	attr.set_value(&engineeringGapAxesSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringGapSpeed
}

//--------------------------------------------------------
/**
 *	Write EngineeringGapSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringGapSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringGapSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringGapSpeed) ENABLED START -----*/

	Tango::DeviceAttribute devattr("velocity", w_val);

	// Write attributes.
    gapAxesGroup->write_attribute(devattr, false);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringGapSpeed
}

//--------------------------------------------------------
/**
 *	Read EngineeringPhaseSpeed attribute
 *	Description: Final profile velocity in um/s for phase axes engineering movement.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringPhaseSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringPhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringPhaseSpeed) ENABLED START -----*/

    // Get values.
    Tango::GroupAttrReplyList replyList = phaseAxesGroup->read_attribute("velocity", false);

    // Check if read failed.
    if(replyList.has_failed())
    {
        ERROR_STREAM << "Error reading engineering phase speed." << endl;
        attr.set_quality(Tango::ATTR_INVALID);
    }
    else
    {
        double tempSpeed;

        // Extract first velocity.
        replyList[0] >> engineeringPhaseAxesSpeed;

        for(uint i = 1; i < replyList.size(); i++)
        {
            // Extract others and compare. If all are the same show speed otherwise show zero.
            replyList[i] >> tempSpeed;
            if(engineeringPhaseAxesSpeed != tempSpeed)
            {
                engineeringPhaseAxesSpeed = 0;
                break;
            }
        }
        attr.set_quality(Tango::ATTR_VALID);
    }
    //  Set the attribute value
	attr.set_value(&engineeringPhaseAxesSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringPhaseSpeed
}

//--------------------------------------------------------
/**
 *	Write EngineeringPhaseSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringPhaseSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringPhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringPhaseSpeed) ENABLED START -----*/

    Tango::DeviceAttribute devattr("velocity", w_val);

    // Write attributes.
    phaseAxesGroup->write_attribute(devattr);


	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringPhaseSpeed
}

//--------------------------------------------------------
/**
 *	Read EngineeringGapAcceleration attribute
 *	Description: Gap axes engineering movement average acceleration/deceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringGapAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringGapAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringGapAcceleration) ENABLED START -----*/

    vector<string> attrNames;
    attrNames.push_back("acceleration");
    attrNames.push_back("deceleration");
    Tango::GroupAttrReplyList replyList = gapAxesGroup->read_attributes(attrNames, false);

    // Check if read failed.
    if(replyList.has_failed())
    {
        ERROR_STREAM << "Error reading engineering gap acceleration." << endl;
        attr.set_quality(Tango::ATTR_INVALID);
    }
    else
    {
        replyList[0] >> engineeringGapAxesAcceleration; // Get first value.

        double tempAcc;

        // Go through all values and if all are the same set it to attribute otherwise set to 0.
        for(uint i = 1; i < replyList.size(); i++)
        {
            replyList[i] >> tempAcc;
            if(engineeringGapAxesAcceleration != tempAcc)
            {
                engineeringGapAxesAcceleration = 0;
                break;
            }
        }
        attr.set_quality(Tango::ATTR_VALID);
    }
    //  Set the attribute value
	attr.set_value(&engineeringGapAxesAcceleration);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringGapAcceleration
}

//--------------------------------------------------------
/**
 *	Write EngineeringGapAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringGapAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringGapAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringGapAcceleration) ENABLED START -----*/

	Tango::DeviceAttribute devattr("acceleration", w_val);

    // Write acceleration attributes.
    gapAxesGroup->write_attribute(devattr);

    // Write deceleration attributes.
    devattr.set_name("deceleration"); // Set the name of attribute.
    gapAxesGroup->write_attribute(devattr);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringGapAcceleration
}

//--------------------------------------------------------
/**
 *	Read EngineeringPhaseAcceleration attribute
 *	Description: Phase axes engineering movement average acceleration/deceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringPhaseAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringPhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringPhaseAcceleration) ENABLED START -----*/

	vector<string> attrNames;
    attrNames.push_back("acceleration");
    attrNames.push_back("deceleration");
    Tango::GroupAttrReplyList replyList = phaseAxesGroup->read_attributes(attrNames, false);

    // Check if read failed.
    if(replyList.has_failed())
    {
        ERROR_STREAM << "Error reading engineering phase acceleration." << endl;
        attr.set_quality(Tango::ATTR_INVALID);
    }
    else
    {
        replyList[0] >> engineeringPhaseAxesAcceleration; // Get first.
        double tempAcc;

        // Go through all values and if all are the same set it to attribute otherwise set to 0.
        for(uint i = 1; i < replyList.size(); i++)
        {
            replyList[i] >> tempAcc;
            if(engineeringPhaseAxesAcceleration != tempAcc)
            {
                engineeringPhaseAxesAcceleration = 0;
                break;
            }
        }
        attr.set_quality(Tango::ATTR_VALID);
    }
    //  Set the attribute value
    attr.set_value(&engineeringPhaseAxesAcceleration);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringPhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Write EngineeringPhaseAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringPhaseAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringPhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringPhaseAcceleration) ENABLED START -----*/

    Tango::DeviceAttribute devattr("acceleration", w_val);

    // Write acceleration attributes.
    phaseAxesGroup->write_attribute(devattr);

    // Write deceleration attributes.
    devattr.set_name("deceleration"); // Set the name of attribute.
    phaseAxesGroup->write_attribute(devattr);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringPhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Read Interlock attribute
 *	Description: Indicates that interlock is in effect.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Interlock(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Interlock(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Interlock) ENABLED START -----*/

	//	Set the attribute value

	// Send command to get interlock status.

	interlock = galilFunctions->get_interlock_status();

	attr.set_value(&interlock);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Interlock
}
//--------------------------------------------------------
/**
 *	Read Coil1 attribute
 *	Description: Coil1 Current Setpoint/Readback
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Coil1(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Coil1(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Coil1) ENABLED START -----*/

	//	Set the attribute value
	currentCoil1 = supplies->get_current(0);
	attr.set_value(&currentCoil1);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Coil1
}

//--------------------------------------------------------
/**
 *	Write Coil1 attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Coil1(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Coil1(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Coil1) ENABLED START -----*/
	if(coilCorrectionEnabled)
	    Tango::Except::throw_exception("Can't set current when running in automatic mode.","",__PRETTY_FUNCTION__);

	desiredCurrent[0] = w_val;

	supplies->set_current(w_val,0);
	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Coil1
}

//--------------------------------------------------------
/**
 *	Read Coil2 attribute
 *	Description: Coil2 Current Setpoint/Readback
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Coil2(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Coil2(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Coil2) ENABLED START -----*/

	//	Set the attribute value
	currentCoil2 = supplies->get_current(1);
	attr.set_value(&currentCoil2);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Coil2
}

//--------------------------------------------------------
/**
 *	Write Coil2 attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Coil2(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Coil2(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Coil2) ENABLED START -----*/
	if(coilCorrectionEnabled)
	    Tango::Except::throw_exception("Can't set current when running in automatic mode.","",__PRETTY_FUNCTION__);

	desiredCurrent[1] = w_val;
	supplies->set_current(w_val, 1);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Coil2
}

//--------------------------------------------------------
/**
 *	Read Coil3 attribute
 *	Description: Coil3 Current Setpoint/Readback
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Coil3(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Coil3(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Coil3) ENABLED START -----*/

	//	Set the attribute value
	currentCoil3 = supplies->get_current(2);
	attr.set_value(&currentCoil3);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Coil3
}

//--------------------------------------------------------
/**
 *	Write Coil3 attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Coil3(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Coil3(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Coil3) ENABLED START -----*/
	if(coilCorrectionEnabled)
	    Tango::Except::throw_exception("Can't set current when running in automatic mode.","",__PRETTY_FUNCTION__);

	desiredCurrent[2] = w_val;
	supplies->set_current(w_val, 2);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Coil3
}

//--------------------------------------------------------
/**
 *	Read Coil4 attribute
 *	Description: Coil4 Current Setpoint/Readback
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Coil4(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Coil4(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Coil4) ENABLED START -----*/


	//	Set the attribute value
	currentCoil4 = supplies->get_current(3);
	attr.set_value(&currentCoil4);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Coil4
}

//--------------------------------------------------------
/**
 *	Write Coil4 attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Coil4(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Coil4(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Coil4) ENABLED START -----*/
	if(coilCorrectionEnabled)
	    Tango::Except::throw_exception("Can't set current when running in automatic mode.","",__PRETTY_FUNCTION__);

	desiredCurrent[3] = w_val;
	supplies->set_current(w_val,3);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Coil4
}

//--------------------------------------------------------
/**
 *	Read CorrectionEnabled attribute
 *	Description: Enables correction.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_CorrectionEnabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_CorrectionEnabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_CorrectionEnabled) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&coilCorrectionEnabled);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_CorrectionEnabled
}

//--------------------------------------------------------
/**
 *	Write CorrectionEnabled attribute values to hardware.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_CorrectionEnabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_CorrectionEnabled(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_CorrectionEnabled) ENABLED START -----*/

	if(w_val)
	    start_coils_automatic();
	else
	    start_coils_manual();

	coilCorrectionEnabled = w_val;
	
	/*----- PROTECTED REGION END -----*/	//	Undulator::write_CorrectionEnabled
}


//--------------------------------------------------------
/**
 *	Method      : Undulator::UndulatorClass::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *	              for specified device.
 */
//--------------------------------------------------------
void Undulator::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Undulator::Class::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	Undulator::Class::add_dynamic_attributes

}



//========================================================
//	Command execution methods
//========================================================

//--------------------------------------------------------
/**
 *	Execute the StopGap command:
 *	Description: Stops gap movement.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::stop_gap()
{
	DEBUG_STREAM << "Undulator::StopGap()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::stop_gap) ENABLED START -----*/

	//	Add your own code

	// Sends command to stop gap motors.
	galilFunctions->stop_gap();

	/*----- PROTECTED REGION END -----*/	//	Undulator::stop_gap

}

//--------------------------------------------------------
/**
 *	Execute the ToggleStopAll command:
 *	Description: Emergency stop all command. 
 *	             If called with the parameter set to TRUE, aborts all motion 
 *	             and inhibits all further requests for motion until the command 
 *	             is invoked again with the parameter set to FALSE.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::toggle_stop_all(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "Undulator::ToggleStopAll()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::toggle_stop_all) ENABLED START -----*/

	// Set or reset stop all
    galilFunctions->toggle_stop_all(argin);
    stopAll = argin;

	/*----- PROTECTED REGION END -----*/	//	Undulator::toggle_stop_all

}

//--------------------------------------------------------
/**
 *	Execute the DisableLimits command:
 *	Description: Disable software limits on the DMC. 
 *	             Set parameter to TRUE to disable the limits. 
 *	             To re-enable the limits invcoke command with FALSE parameter.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::disable_limits(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "Undulator::DisableLimits()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::disable_limits) ENABLED START -----*/

	if(argin)
	{
	    galilFunctions->disable_limits();
	    limitsDisabled = true;
	}
	else
	{
	    // Enable the limits.
	    set_soft_limits_phase();
	    set_soft_limits_gap();
	    limitsDisabled = false;
	}
	/*----- PROTECTED REGION END -----*/	//	Undulator::disable_limits

}

//--------------------------------------------------------
/**
 *	Execute the StopPhase command:
 *	Description: Stops phase movement.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::stop_phase()
{
	DEBUG_STREAM << "Undulator::StopPhase()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::stop_phase) ENABLED START -----*/

	// Sends command to stop gap motors.
	galilFunctions->stop_phase();

	/*----- PROTECTED REGION END -----*/	//	Undulator::stop_phase

}

//--------------------------------------------------------
/**
 *	Execute the CalibrateGap command:
 *	Description: Calculates gap axes offsets using given gap and center and reading positions from encoders.
 *
 *	@param argin Current gap and center.
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::calibrate_gap(const Tango::DevVarDoubleArray *argin)
{
	DEBUG_STREAM << "Undulator::CalibrateGap()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::calibrate_gap) ENABLED START -----*/

	// Create a vector to fill with aux encoder positions.
    vector<double> encoderPos;

    galilFunctions->get_gap_auxiliary_encoder_pos(encoderPos);

    // Get current offsets.
    get_offsets_gap();

    // Recalculate.
    double gapCenter = (*argin)[0]/2 + (*argin)[1]; // G/2+center

    offsetsGapVector[2] = -gapCenter - convert_to_micrometers(encoderPos[2], positionRatioGap);     // -G/2+center = TDC + offset[2]
    offsetsGapVector[3] = -gapCenter - convert_to_micrometers(encoderPos[3], positionRatioGap);     // -G/2+center = TDD + offset[3]

    offsetsGapVector[0] = gapCenter - convert_to_micrometers(encoderPos[0] - encoderPos[2], positionRatioGap); // G/2+center = TDA + TDC + Offsets[0]
    offsetsGapVector[1] = gapCenter - convert_to_micrometers(encoderPos[1] - encoderPos[3], positionRatioGap); // G/2+center = TDB + TDC + Offsets[1]

    // Update offsets.
    gapAxesGroup->write_attribute("offset", offsetsGapVector, false);


	/*----- PROTECTED REGION END -----*/	//	Undulator::calibrate_gap

}

//--------------------------------------------------------
/**
 *	Execute the CalibratePhase command:
 *	Description: Calculates phase axes offsets on zero phase.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::calibrate_phase()
{
	DEBUG_STREAM << "Undulator::CalibratePhase()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::calibrate_phase) ENABLED START -----*/

    Tango::GroupAttrReplyList replyList = phaseAxesGroup->read_attribute("position", false);
    if(replyList.has_failed() == 1)
            Tango::Except::throw_exception("Error in reading phase axes position attribute.",
                "Read_attribute function failed.","calibrate_phase()", Tango::ERR);

    // Get current offsets.
    get_offsets_phase();

    // Recalculate new offsets.
    // Offsets are equal to "old offset - current position" since we are a 0.
    double extractor;
    for(uint i = 0; i < replyList.size(); i++)
    {
        replyList[i] >> extractor;
        offsetsPhaseVector[i] -= extractor;
    }

    // Update offsets.
    phaseAxesGroup->write_attribute("offset", offsetsPhaseVector, false);


	/*----- PROTECTED REGION END -----*/	//	Undulator::calibrate_phase

}

//--------------------------------------------------------
/**
 *	Execute the LoadCorrectionData command:
 *	Description: Loads the interpolation data for the coil correction from a file.
 *	              
 *	             Load can not be called while running. The data could be shared with the thread without locking.
 *
 *	@param argin filename
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::load_correction_data(Tango::DevString argin)
{
	DEBUG_STREAM << "Undulator::LoadCorrectionData()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::load_correction_data) ENABLED START -----*/

	ifstream inFile(argin);

    if (!inFile.good())
    {
        dataFileLoaded=false;
	    Tango::Except::throw_exception("Invalid filename provided.","The file-name in the argument could not be opened.",__PRETTY_FUNCTION__);
    }

    int n = count(istreambuf_iterator<char>(inFile), istreambuf_iterator<char>(), '\n');

    if (n<=1)
    {
        dataFileLoaded=false;
	    Tango::Except::throw_exception("The file does not contain any data.","",__PRETTY_FUNCTION__);
    }
    data.clear();
    data.reserve(n);

    inFile.seekg(0,ios_base::beg);

    string line;
    // read the first header line
    std::getline(inFile,line);

    // Load the data
    DataItem item;
    while (true)
    {
	    inFile >> item;
	    if (!inFile.good()) break;

	    //cout << item;

	    item.normalize();

	    data.push_back(item);
    }

    dataFileLoaded = true;

	/*----- PROTECTED REGION END -----*/	//	Undulator::load_correction_data

}
	/*----- PROTECTED REGION ID(Undulator::namespace_ending) ENABLED START -----*/

/**
 * Calculates final destinations of phase axes depending on desired phase.
 *
 * @param destinations Destinations vector to fill.
 */
void Undulator::calculate_motor_destinations(vector<double> &destinations)
{
    // Convert desiredOffset to counts.
    double counts = convert_to_counts(desiredOffset, positionRatioPhase);

    // Put all 4 destinations to 0.
    for(int i = 0; i < 4; i++)
        destinations.push_back(0);

    // Fix the two destinations based on phase mode.
    switch(desiredPhase)
    {
        // Phase A - X1 and X4 fixed, X2 and X3 move parallel to desired offset.
        case 0:
            destinations[1] = counts;
            destinations[2] = counts;
            break;
        // Phase B - X2 and X3 fixed, X1 and X4 move parallel to desired offset.
        case 1:
            destinations[0] = counts;
            destinations[3] = counts;
            break;
        // Phase C - X1 and X4 fixed, X2 and X3 move antiparallel to desired offset.
        case 2:
            destinations[1] = counts;
            destinations[2] = -counts;
            break;
        // Phase D - X2 and X3 fixed, X1 and X4 move antiparallel to desired offset.
        case 3:
            destinations[0] = counts;
            destinations[3] = -counts;
            break;
        // Nothing to change leave all at phase center.
        default:
            break;
    }
}

/**
 *  Gets offsets from all gap axes and stores them in offsetsGap vector.
 */
void Undulator::get_offsets_gap()
{
    Tango::GroupAttrReplyList replyList = gapAxesGroup->read_attribute("offset", false);
    if(replyList.has_failed() == 1)
        Tango::Except::throw_exception("Error in reading gap offset attributes.",
            "Read_attribute function failed.","get_offsets_gap()", Tango::ERR);

    offsetsGapVector.clear();
    double extractor;

    for(uint i = 0; i < replyList.size(); i++)
    {
        replyList[i] >> extractor;
        offsetsGapVector.push_back(extractor);
    }
}

/**
 *  Gets offsets from all phase axes and stores them in offsetsPhase vector.
 */
void Undulator::get_offsets_phase()
{
    Tango::GroupAttrReplyList replyList = phaseAxesGroup->read_attribute("offset", false);
    if(replyList.has_failed() == 1)
        Tango::Except::throw_exception("Error in reading phase offset attributes.",
            "Read_attribute function failed.","get_offsets_phase()", Tango::ERR);

    offsetsPhaseVector.clear();
    double extractor;

    for(uint i = 0; i < replyList.size(); i++)
    {
        replyList[i] >> extractor;
        offsetsPhaseVector.push_back(extractor);
    }
}


/**
 * Takes user unit and converts it to counts.
 *
 * @param number User unit to convert to counts.
 * @param ratio Ratio to use for conversion.
 * @return Converted user units in counts.
 */
double Undulator::convert_to_counts(double number, double ratio)
{
    return number/ratio;
}

/**
 * Calculates software limits for gap and sets them on DMC.
 */
void Undulator::set_soft_limits_gap()
{
    // Calculate current limits depending on center, taper and min/max gap.
    vector<double> forwardLimits;
    vector<double> backwardLimits;

    // Update offsets.
    get_offsets_gap();

    forwardLimits.push_back(convert_to_counts(desiredCenter - desiredTaper/4 + maxGap/2 - offsetsGapVector[0], positionRatioGap)); // FLZ1
    backwardLimits.push_back(convert_to_counts(desiredCenter - desiredTaper/4 + minGap/2- offsetsGapVector[0], positionRatioGap)); // BLZ1

    forwardLimits.push_back(convert_to_counts(desiredCenter + desiredTaper/4 + maxGap/2 - offsetsGapVector[1], positionRatioGap)); // FLZ2
    backwardLimits.push_back(convert_to_counts(desiredCenter + desiredTaper/4 + minGap/2 - offsetsGapVector[1], positionRatioGap)); // BLZ2

    forwardLimits.push_back(convert_to_counts(desiredCenter + desiredTaper/4 - minGap/2 - offsetsGapVector[2], positionRatioGap)); // FLZ3
    backwardLimits.push_back(convert_to_counts(desiredCenter + desiredTaper/4 - maxGap/2 - offsetsGapVector[2], positionRatioGap)); // BLZ3

    forwardLimits.push_back(convert_to_counts(desiredCenter - desiredTaper/4 - minGap/2 - offsetsGapVector[3], positionRatioGap)); // FLZ4
    backwardLimits.push_back(convert_to_counts(desiredCenter - desiredTaper/4 - maxGap/2 - offsetsGapVector[3], positionRatioGap)); // BLZ4

    galilFunctions->set_gap_limits(forwardLimits, backwardLimits);
}

/**
 * Calculates software limits for phase and sets them on DMC.
 */
void Undulator::set_soft_limits_phase()
{
    // Calculate current limits depending on max operator offset.
    vector<double> forwardLimits;
    vector<double> backwardLimits;

    // Update offsets.
    get_offsets_phase();

    // Calculate limits and apply offsets.
    for(int i = 0; i < 4; i++)
    {
        forwardLimits.push_back(convert_to_counts(maxOpPhase - offsetsPhaseVector[i], positionRatioPhase));
        backwardLimits.push_back(convert_to_counts(-maxOpPhase - offsetsPhaseVector[i], positionRatioPhase));
    }

    galilFunctions->set_phase_limits(forwardLimits, backwardLimits);
}

/**
 * Converts counts to micrometers using given ratio.
 *
 * @param value Value to convert to micrometers.
 * @param ratio Ratio to use for conversion.
 * @return Converted value.
 */
double Undulator::convert_to_micrometers(double value, double ratio)
{
    return value * ratio;
}

/**
 * Sends all required parameters for gap movement and starts it on DMC.
 */
void Undulator::start_gap()
{
    // Deny move if in engineering mode.
    if(engineeringLock)
    {
        ERROR_STREAM << "Engineering lock is enabled. Movement denied." << endl;

        Tango::Except::throw_exception("Engineering lock enabled.",
                    "Move gap not permitted under engineering lock.","Move gap command.",Tango::WARN);
        return;
    }

    gapParameters parameters;

    // Update offsets.
    get_offsets_gap();

    // Create vector with offsets in counts.
    for(int i = 0; i < 4; i++)
        parameters.offsets.push_back(convert_to_counts(offsetsGapVector[i], positionRatioGap));

    parameters.gap = convert_to_counts(desiredGap, positionRatioGap);
    parameters.offset = convert_to_counts(desiredCenter, positionRatioGap);
    parameters.taper = convert_to_counts(desiredTaper, positionRatioGap);
    parameters.gapSpeed = convert_to_counts(gapSpeed, positionRatioGap);
    parameters.taperSpeed = convert_to_counts(taperSpeed, positionRatioGap);
    parameters.gapAcceleration = convert_to_counts(gapAcc, positionRatioGap);
    parameters.taperAcceleration = convert_to_counts(taperAcc, positionRatioGap);

    // Send to DMC.
    galilFunctions->start_gap_movement(parameters);

    // If we are here means there were no exceptions and gap is moving.
    gapMoving = true;

}

/**
 * Calculates final motor positions, sends required parameters
 * and starts phase movement on DMC.
 */
void Undulator::start_phase()
{
    // If lock or operator wants too much offset we deny.
    if(engineeringLock)
    {
        ERROR_STREAM << "Engineering lock enabled. Movement denied." << endl;
        Tango::Except::throw_exception("Engineering lock or out of bounds max operator phase offset desired.",
                            "Move phase not permitted under current conditions","Start move phase command.",Tango::WARN);
        return;
    }

    phaseParameters parameters;

    // Calculate final destinations and correct vector.
    calculate_motor_destinations(parameters.finalAxisPos);

    // Update offsets.
    get_offsets_phase();

    // Create vector with offsets in counts.
    for(int i = 0; i < 4; i++)
        parameters.offsets.push_back(convert_to_counts(offsetsPhaseVector[i], positionRatioPhase));

    // Set other needed parameters.
    parameters.phaseMode = desiredPhase;
    parameters.phaseSpeed = convert_to_counts(phaseSpeed*VECTOR_UNIT_TO_INDIVIDUAL, positionRatioPhase);
    parameters.phaseAcceleration = convert_to_counts(phaseAcc*VECTOR_UNIT_TO_INDIVIDUAL, positionRatioPhase);

    // Send to DMC.
    galilFunctions->start_phase_movement(parameters);

    // If we are here means there were no exceptions and phase is moving.
    phaseMoving = true;
}

void Undulator::start_coils_manual()
{
    pollerThread->set_compensate(false);

    for (int i =0; i < 4; i++)
        supplies->set_current(desiredCurrent[i], i);

}

void Undulator::start_coils_automatic()
{
    if(!dataFileLoaded)
        Tango::Except::throw_exception("Data file is not loaded.","",__PRETTY_FUNCTION__);

    // Turn on compensation
    pollerThread->set_compensate(true);

}

	/*----- PROTECTED REGION END -----*/	//	Undulator::namespace_ending
} //	namespace
