/*----- PROTECTED REGION ID(Undulator.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        Undulator.cpp
//
// description : C++ source for the Undulator and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Undulator are implemented in this file.
//
// project :     .
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL:  $
//
// CVS only:
// $Source:  $
// $Log:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <Undulator.h>
#include <UndulatorClass.h>
#include <cmath>

#include "insertion/UpdaterThread.h"
#include "correction/PollerThread.h"

/*----- PROTECTED REGION END -----*/


/**
 *	Undulator class description:
 *	Device server for controling movement of undulator axes. 
 *	It features gap movement and phase movement in 4 modes.
 *	In expert mode, user can configure the behaviour of axes and restrict certain actions.
 */

//================================================================
//
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name        |  Method name
//----------------------------------------------------------------
//  State               |  Inherited (no method)
//  Status              |  Inherited (no method)
//  StopGap             |  stop_gap
//  ToggleStopAll       |  toggle_stop_all
//  DisableLimits       |  disable_limits
//  StopPhase           |  stop_phase
//  CalibrateGap        |  calibrate_gap
//  CalibratePhase      |  calibrate_phase
//  LoadCorrectionData  |  load_correction_data
//================================================================

namespace Undulator_ns
{
	/*----- PROTECTED REGION ID(Undulator::namespace_starting) ENABLED START -----*/





	/*----- PROTECTED REGION END -----*/	//	Undulator::namespace_starting



//--------------------------------------------------------
/**
 *	Method      : Undulator::Undulator()
 *	Description : Constructors for a Tango device
 *	              implementing the class Undulator
 */
//--------------------------------------------------------
Undulator::Undulator(Tango::DeviceClass *cl, string &s)
 	: Tango::Device_4Impl(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(Undulator::constructor_1) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Undulator::constructor_1
}
//--------------------------------------------------------
Undulator::Undulator(Tango::DeviceClass *cl, const char *s)
 	: Tango::Device_4Impl(cl, s)
{
	/*----- PROTECTED REGION ID(Undulator::constructor_2) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Undulator::constructor_2
}
//--------------------------------------------------------
Undulator::Undulator(Tango::DeviceClass *cl, const char *s, const char *d)
 	: Tango::Device_4Impl(cl, s, d)
{
	/*----- PROTECTED REGION ID(Undulator::constructor_3) ENABLED START -----*/

	init_device();

	/*----- PROTECTED REGION END -----*/	//	Undulator::constructor_3
}


//--------------------------------------------------------
/**
 *	Method      : Undulator::delete_device()()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Undulator::delete_device()
{
	/*----- PROTECTED REGION ID(Undulator::delete_device) ENABLED START -----*/

	//	Delete device allocated objects
	if (stateUpdater)
	{
		stateUpdater->abort();
		stateUpdater->join(0);
		stateUpdater = 0;
	}

	if (pollerThread)
	{
		pollerThread->abort();
		pollerThread->join(0);
		pollerThread = 0;
	}
	supplies.reset(0);

    if (gapA) delete gapA;
    if (gapB) delete gapB;
    if (gapC) delete gapC;
    if (gapD) delete gapD;
    if (phaseA) delete phaseA;
    if (phaseB) delete phaseB;
    if (phaseC) delete phaseC;
    if (phaseD) delete phaseD;
    if (controlBoxGap) delete controlBoxGap;
    if (controlBoxPhase) delete controlBoxPhase;

	/*----- PROTECTED REGION END -----*/	//	Undulator::delete_device
	delete[] attr_Coil1_read;
	delete[] attr_Coil2_read;
	delete[] attr_Coil3_read;
	delete[] attr_Coil4_read;
	delete[] attr_CorrectionEnabled_read;
	
}


//--------------------------------------------------------
/**
 *	Method      : Undulator::init_device()
 *	Description : //	will be called at device initialization.
 */
//--------------------------------------------------------
void Undulator::init_device()
{
	DEBUG_STREAM << "Undulator::init_device() create device " << device_name << endl;

	/*----- PROTECTED REGION ID(Undulator::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call

	/*----- PROTECTED REGION END -----*/	//	Undulator::init_device_before
	
	//	Get the device properties (if any) from database
	get_device_property();
	
	attr_Coil1_read = new Tango::DevDouble[1];
	attr_Coil2_read = new Tango::DevDouble[1];
	attr_Coil3_read = new Tango::DevDouble[1];
	attr_Coil4_read = new Tango::DevDouble[1];
	attr_CorrectionEnabled_read = new Tango::DevBoolean[1];
	
	/*----- PROTECTED REGION ID(Undulator::init_device) ENABLED START -----*/

	// Initialize pointers to null
	stateUpdater=0;
	gapA=gapB=gapC=gapD=phaseA=phaseB=phaseC=phaseD=0;
	controlBoxGap=controlBoxPhase=0;

	//	Initialize device
	//! Variables to 0.
	gap = 0;
	center = 0;
	taper = 0;
	phase = -1;
	phaseOffset = 0;
	phaseCenter = 0;

	minGap = 0;
	maxGap = 0;
	maxOpPhase = 0;

	gapAcc = 0;
	phaseAcc = 0;
	taperAcc = 0;

	gapSpeed = 0;
	taperSpeed = 0;
	phaseSpeed = 0;

	desiredGap = 0;
	desiredCenter = 0;
	desiredTaper = 0;

	desiredPhase = 0;
	desiredOffset = 0;

	interlock = false;

	phaseMoving = false;
	gapMoving = false;
	stopAll = false;
	limitsDisabled = false;
	engineeringLock = false;

	try
	{
	    // Device proxy initialization.
	    // Gap axes.
	    gapA = new Tango::DeviceProxy(gapAxes[0]);
	    gapB = new Tango::DeviceProxy(gapAxes[1]);
	    gapC = new Tango::DeviceProxy(gapAxes[2]);
	    gapD = new Tango::DeviceProxy(gapAxes[3]);

	    // Phase axes.
	    phaseA = new Tango::DeviceProxy(phaseAxes[0]);
	    phaseB = new Tango::DeviceProxy(phaseAxes[1]);
	    phaseC = new Tango::DeviceProxy(phaseAxes[2]);
	    phaseD = new Tango::DeviceProxy(phaseAxes[3]);

	    // Control box links.
	    controlBoxGap = new Tango::DeviceProxy(controlBoxGapLink);
	    controlBoxPhase = new Tango::DeviceProxy(controlBoxPhaseLink);


	    // Read counts to micrometer ratio.
	    Tango::DbData deviceProperty;
	    string propertyName = "AxisPositionRatio";

	    // Read from first gap axis since all should be the same.
	    gapA->get_property(propertyName , deviceProperty);
	    deviceProperty[0] >> positionRatioGap;

	    // Same for phase axis.
	    phaseA->get_property(propertyName , deviceProperty);
	    deviceProperty[0] >> positionRatioPhase;

	    // Get offset for each axis.
	    get_offsets();

	    // Set tango state to ON.
	    this->set_state(Tango::ON);

	    // Start thread for state and position updates.
	    stateUpdater = new UpdaterThread(*this, 1000, gapAxes, phaseAxes, gearedAxes);
	    stateUpdater->go();


	    //TODO:refactor?
	    //Try to load the interpolation data table from the provided DataFile property
	    bool loadOk=true;
	    try {
	    	load_correction_data(const_cast<char*>(dataFile.c_str()));
	    } catch (...)
	    {
	    	loadOk=false;
	    }
	    // Start correction thread
	    pollerThread = new PollerThread(*this, controlBoxGapLink, controlBoxPhaseLink);
	    pollerThread->go();

	    //TODO: this should not be in the initmethod?
	    //If the data was loaded OK
	    if (loadOk){
	    	// Turn on the power supplies
	    	for (int i=0;i<4;i++)
	    	{
	    		supplies[i].on();
	    	}
	    	// Turn on compensation
	    	pollerThread->set_compensate(true);
	    }
	}
	catch(Tango::DevFailed& err)
	{
	    this->set_state(Tango::FAULT);
	    stringstream msg;
	    msg << "Tango exception in initialization." << endl
	            << "Reason: " << err.errors[0].reason << endl
	            << "Description: " << err.errors[0].desc;

	    this->set_status(msg.str());
	}
	catch(std::exception& err)
	{
	    this->set_state(Tango::FAULT);
	    this->set_status(err.what());
	}
	catch(...)
	{
	    this->set_state(Tango::FAULT);
	    this->set_status("Unknown exception occurred in initialization.");
	}
	/*----- PROTECTED REGION END -----*/	//	Undulator::init_device
}



//--------------------------------------------------------
/**
 *	Method      : Undulator::get_device_property()
 *	Description : //	Add your own code to initialize
 */
//--------------------------------------------------------
void Undulator::get_device_property()
{
	/*----- PROTECTED REGION ID(Undulator::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	Undulator::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("ControlBoxGapLink"));
	dev_prop.push_back(Tango::DbDatum("GapAxes"));
	dev_prop.push_back(Tango::DbDatum("PhaseAxes"));
	dev_prop.push_back(Tango::DbDatum("ControlBoxPhaseLink"));
	dev_prop.push_back(Tango::DbDatum("GearedAxes"));
	dev_prop.push_back(Tango::DbDatum("DataFile"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on UndulatorClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		UndulatorClass	*ds_class =
			(static_cast<UndulatorClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize ControlBoxGapLink from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  controlBoxGapLink;
		else {
			//	Try to initialize ControlBoxGapLink from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  controlBoxGapLink;
		}
		//	And try to extract ControlBoxGapLink value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  controlBoxGapLink;

		//	Try to initialize GapAxes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gapAxes;
		else {
			//	Try to initialize GapAxes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gapAxes;
		}
		//	And try to extract GapAxes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gapAxes;

		//	Try to initialize PhaseAxes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  phaseAxes;
		else {
			//	Try to initialize PhaseAxes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  phaseAxes;
		}
		//	And try to extract PhaseAxes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  phaseAxes;

		//	Try to initialize ControlBoxPhaseLink from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  controlBoxPhaseLink;
		else {
			//	Try to initialize ControlBoxPhaseLink from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  controlBoxPhaseLink;
		}
		//	And try to extract ControlBoxPhaseLink value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  controlBoxPhaseLink;

		//	Try to initialize GearedAxes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  gearedAxes;
		else {
			//	Try to initialize GearedAxes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  gearedAxes;
		}
		//	And try to extract GearedAxes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gearedAxes;

		//	Try to initialize DataFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dataFile;
		else {
			//	Try to initialize DataFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dataFile;
		}
		//	And try to extract DataFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dataFile;


	}
	/*----- PROTECTED REGION ID(Undulator::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	Undulator::get_device_property_after

}

//--------------------------------------------------------
/**
 *	Method      : Undulator::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void Undulator::always_executed_hook()
{
	INFO_STREAM << "Undulator::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::always_executed_hook) ENABLED START -----*/


	/*----- PROTECTED REGION END -----*/	//	Undulator::always_executed_hook
}



//--------------------------------------------------------
/**
 *	Method      : Undulator::read_attr_hardware()
 *	Description : Hardware acquisition for attributes.
 */
//--------------------------------------------------------
void Undulator::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "Undulator::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_attr_hardware) ENABLED START -----*/



	/*----- PROTECTED REGION END -----*/	//	Undulator::read_attr_hardware

}


//--------------------------------------------------------
/**
 *	Read GapReadback attribute
 *	Description: Read-back value for the current gap
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapReadback(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapReadback(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapReadback) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&gap);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapReadback
}
//--------------------------------------------------------
/**
 *	Read GapSetpoint attribute
 *	Description: Set-point for current gap. 
 *	             Writing to this attribute commences movement for the gap, 
 *	             using the current operator center offset and taper.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapSetpoint(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapSetpoint(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapSetpoint) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&desiredGap);

	// Read max phase offset value from properties.
    Tango::AttributeConfig confGap;
    attr.get_properties(confGap);

    // Convert string to double.
    double max = atof(confGap.max_value);
    double min = atof(confGap.min_value);

    // If new maximum/minimum set, update them and recalculate new limits.
    if((max != maxGap) || (min != minGap))
    {
	    maxGap = max;
	    minGap = min;

	    if (!limitsDisabled)
	        set_soft_limits_gap();
    }

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapSetpoint
}

//--------------------------------------------------------
/**
 *	Write GapSetpoint attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_GapSetpoint(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_GapSetpoint(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_GapSetpoint) ENABLED START -----*/

	desiredGap = w_val;
	
	start_gap();

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_GapSetpoint
}

//--------------------------------------------------------
/**
 *	Read EngineeringLock attribute
 *	Description: Setting this attribute to TRUE disables operator composite movements. 
 *	             Engineering movements to be done directly on the ControlBox axis devices.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringLock(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringLock(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringLock) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&engineeringLock);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringLock
}

//--------------------------------------------------------
/**
 *	Write EngineeringLock attribute values to hardware.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringLock(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringLock(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringLock) ENABLED START -----*/

	engineeringLock = static_cast<bool>(w_val);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringLock
}

//--------------------------------------------------------
/**
 *	Read GapAcceleration attribute
 *	Description: Gap movement average acceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapAcceleration) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&gapAcc);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapAcceleration
}

//--------------------------------------------------------
/**
 *	Write GapAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_GapAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_GapAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_GapAcceleration) ENABLED START -----*/

	gapAcc = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_GapAcceleration
}

//--------------------------------------------------------
/**
 *	Read GapSpeed attribute
 *	Description: Final profile velocity in um/s for gap movements.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapSpeed) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&gapSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapSpeed
}

//--------------------------------------------------------
/**
 *	Write GapSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_GapSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_GapSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_GapSpeed) ENABLED START -----*/

    gapSpeed = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_GapSpeed
}

//--------------------------------------------------------
/**
 *	Read OffsetReadback attribute
 *	Description: Read-back value for the current vertical center offset.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_OffsetReadback(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_OffsetReadback(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_OffsetReadback) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&center);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_OffsetReadback
}
//--------------------------------------------------------
/**
 *	Read OffsetSetpoint attribute
 *	Description: Set-point value for the current vertical offset. 
 *	             Will be applied next time the GapSetpoint attribute is modified.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_OffsetSetpoint(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_OffsetSetpoint(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_OffsetSetpoint) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&desiredCenter);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_OffsetSetpoint
}

//--------------------------------------------------------
/**
 *	Write OffsetSetpoint attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_OffsetSetpoint(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_OffsetSetpoint(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_OffsetSetpoint) ENABLED START -----*/

	desiredCenter = w_val;

	// Center changed, set new gap limits.
	if (!limitsDisabled)
	    set_soft_limits_gap();

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_OffsetSetpoint
}

//--------------------------------------------------------
/**
 *	Read PhaseAcceleration attribute
 *	Description: Phase movement average acceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseAcceleration) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&phaseAcc);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Write PhaseAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_PhaseAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_PhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_PhaseAcceleration) ENABLED START -----*/

	phaseAcc = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_PhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Read PhaseModeReadback attribute
 *	Description: Current phase mode.
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseModeReadback(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseModeReadback(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseModeReadback) ENABLED START -----*/

	// Get the current phase mode from DMC.
	send_command("PhMd=?", *controlBoxPhase);
	stringstream convert(devdata_to_string());

	omni_mutex_lock guard(deviceLock);
	convert >> phase;

	//	Set the attribute value
	attr.set_value(&phase);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseModeReadback
}
//--------------------------------------------------------
/**
 *	Read PhaseModeSetpoint attribute
 *	Description: Desired phase mode. 
 *	             Will be used next time PhaseSetpoint is written.
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseModeSetpoint(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseModeSetpoint(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseModeSetpoint) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&desiredPhase);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseModeSetpoint
}

//--------------------------------------------------------
/**
 *	Write PhaseModeSetpoint attribute values to hardware.
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_PhaseModeSetpoint(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_PhaseModeSetpoint(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevShort	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_PhaseModeSetpoint) ENABLED START -----*/

	desiredPhase = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_PhaseModeSetpoint
}

//--------------------------------------------------------
/**
 *	Read PhaseReadback attribute
 *	Description: Current phase offset in um.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseReadback(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseReadback(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseReadback) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&phaseOffset);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseReadback
}
//--------------------------------------------------------
/**
 *	Read PhaseSetpoint attribute
 *	Description: Requested phase offset in um. 
 *	             When this attribute is written new phase movement commences 
 *	             using phase mode specified in PhaseModeSetpoint.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseSetpoint(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseSetpoint(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseSetpoint) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&desiredOffset);

	// Read max phase offset value from properties.
	Tango::AttributeConfig confPhase;
	attr.get_properties(confPhase);

	// Convert string to double.
	double max = atof(confPhase.max_value);

	// If new maximum set, update it and recalculate new limits.
	if(max != maxOpPhase)
	{
	    maxOpPhase = max;

	    if (!limitsDisabled)
	        set_soft_limits_phase();
	}


	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseSetpoint
}

//--------------------------------------------------------
/**
 *	Write PhaseSetpoint attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_PhaseSetpoint(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_PhaseSetpoint(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_PhaseSetpoint) ENABLED START -----*/

	desiredOffset = w_val;
	start_phase();

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_PhaseSetpoint
}

//--------------------------------------------------------
/**
 *	Read PhaseSpeed attribute
 *	Description: Final profile velocity in um/s for phase (sub-girders) movement.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseSpeed) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&phaseSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseSpeed
}

//--------------------------------------------------------
/**
 *	Write PhaseSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_PhaseSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_PhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_PhaseSpeed) ENABLED START -----*/

	phaseSpeed = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_PhaseSpeed
}

//--------------------------------------------------------
/**
 *	Read TaperAcceleration attribute
 *	Description: Taper movement average acceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_TaperAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_TaperAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_TaperAcceleration) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&taperAcc);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_TaperAcceleration
}

//--------------------------------------------------------
/**
 *	Write TaperAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_TaperAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_TaperAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_TaperAcceleration) ENABLED START -----*/

	taperAcc = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_TaperAcceleration
}

//--------------------------------------------------------
/**
 *	Read TaperReadback attribute
 *	Description: Read-back value for the current taper.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_TaperReadback(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_TaperReadback(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_TaperReadback) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&taper);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_TaperReadback
}
//--------------------------------------------------------
/**
 *	Read TaperSetpoint attribute
 *	Description: Set-point value for the current taper. 
 *	             Will be applied next time the GapSetpoint attribute is modified.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_TaperSetpoint(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_TaperSetpoint(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_TaperSetpoint) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&desiredTaper);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_TaperSetpoint
}

//--------------------------------------------------------
/**
 *	Write TaperSetpoint attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_TaperSetpoint(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_TaperSetpoint(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_TaperSetpoint) ENABLED START -----*/

	desiredTaper = w_val;

	// Taper changed, set new gap limits.
	if (!limitsDisabled)
	    set_soft_limits_gap();
	/*----- PROTECTED REGION END -----*/	//	Undulator::write_TaperSetpoint
}

//--------------------------------------------------------
/**
 *	Read TaperSpeed attribute
 *	Description: Final profile velocity in um/s for taper movements.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_TaperSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_TaperSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_TaperSpeed) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&taperSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_TaperSpeed
}

//--------------------------------------------------------
/**
 *	Write TaperSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_TaperSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_TaperSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_TaperSpeed) ENABLED START -----*/

	taperSpeed = w_val;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_TaperSpeed
}

//--------------------------------------------------------
/**
 *	Read LimitsDisabled attribute
 *	Description: Indicates that the software limits on the DMCs are disabled. 
 *	             Useful for commissioning and engineering movements.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_LimitsDisabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_LimitsDisabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_LimitsDisabled) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&limitsDisabled);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_LimitsDisabled
}
//--------------------------------------------------------
/**
 *	Read StopAll attribute
 *	Description: Indicates that the undulator is in StopAll state inhibiting all motion.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_StopAll(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_StopAll(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_StopAll) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(&stopAll);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_StopAll
}
//--------------------------------------------------------
/**
 *	Read GapMoving attribute
 *	Description: Indicates that gap movement is in progress. 
 *	             Used to distinguish whether gap, phase or both are moving.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_GapMoving(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_GapMoving(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_GapMoving) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&gapMoving);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_GapMoving
}
//--------------------------------------------------------
/**
 *	Read PhaseMoving attribute
 *	Description: Indicates that phase movement is in progress. 
 *	             Used to distinguish whether gap, phase or both are moving.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_PhaseMoving(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_PhaseMoving(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_PhaseMoving) ENABLED START -----*/

	//	Set the attribute value
	omni_mutex_lock guard(deviceLock);
	attr.set_value(&phaseMoving);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_PhaseMoving
}
//--------------------------------------------------------
/**
 *	Read EngineeringGapSpeed attribute
 *	Description: Final profile velocity in um/s for gap axes engineering movement.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringGapSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringGapSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringGapSpeed) ENABLED START -----*/

	//	Set the attribute value
	double speedA;
    double speedB;
    double speedC;
    double speedD;
	string attrName = "velocity";

	// Read gap axes speed.
    gapA->read_attribute(attrName) >> speedA;
    gapB->read_attribute(attrName) >> speedB;
    gapC->read_attribute(attrName) >> speedC;
    gapD->read_attribute(attrName) >> speedD;

	// If all values are the same, set speed to value otherwise set speed to 0.
    if( (speedA == speedB) && (speedA == speedC) && (speedA == speedD) )
        engineeringGapAxesSpeed = speedA;
    else
        engineeringGapAxesSpeed = 0;

	attr.set_value(&engineeringGapAxesSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringGapSpeed
}

//--------------------------------------------------------
/**
 *	Write EngineeringGapSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringGapSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringGapSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringGapSpeed) ENABLED START -----*/

	string attrName = "velocity";
	Tango::DeviceAttribute devattr;
	devattr.set_name(attrName); // Set the name of attribute.
    devattr << w_val; // Add value.

	// Write attributes.
	gapA->write_attribute(devattr);
	gapB->write_attribute(devattr);
	gapC->write_attribute(devattr);
	gapD->write_attribute(devattr);




	   // ERROR_STREAM << "Error setting EngineeringGapSpeed." << endl;

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringGapSpeed
}

//--------------------------------------------------------
/**
 *	Read EngineeringPhaseSpeed attribute
 *	Description: Final profile velocity in um/s for phase axes engineering movement.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringPhaseSpeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringPhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringPhaseSpeed) ENABLED START -----*/

	//	Set the attribute value

	// Read 4 axes speeds.
	double speedA;
    double speedB;
    double speedC;
    double speedD;
    string attrName = "velocity";


    phaseA->read_attribute(attrName) >> speedA;
    phaseB->read_attribute(attrName) >> speedB;
    phaseC->read_attribute(attrName) >> speedC;
    phaseD->read_attribute(attrName) >> speedD;

    // If all values are the same, set speed to value otherwise set speed to 0.
    if( (speedA == speedB) && (speedA == speedC) && (speedA == speedD) )
	    engineeringPhaseAxesSpeed = speedA;
    else
	    engineeringPhaseAxesSpeed = 0;

	attr.set_value(&engineeringPhaseAxesSpeed);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringPhaseSpeed
}

//--------------------------------------------------------
/**
 *	Write EngineeringPhaseSpeed attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringPhaseSpeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringPhaseSpeed(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringPhaseSpeed) ENABLED START -----*/

	string attrName = "velocity";
    Tango::DeviceAttribute devattr;
    devattr.set_name(attrName); // Set the name of attribute.
    devattr << w_val; // Add value.


    // Write attributes.
    phaseA->write_attribute(devattr);
    phaseB->write_attribute(devattr);
    phaseC->write_attribute(devattr);
    phaseD->write_attribute(devattr);


	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringPhaseSpeed
}

//--------------------------------------------------------
/**
 *	Read EngineeringGapAcceleration attribute
 *	Description: Gap axes engineering movement average acceleration/deceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringGapAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringGapAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringGapAcceleration) ENABLED START -----*/

	double accA;
    double accB;
    double accC;
    double accD;
    double dcA;
    double dcB;
    double dcC;
    double dcD;

    string attrName = "acceleration";

    // Read gap axes accelerations and decelerations.
    gapA->read_attribute(attrName) >> (accA);
    gapB->read_attribute(attrName) >> (accB);
    gapC->read_attribute(attrName) >> (accC);
    gapD->read_attribute(attrName) >> (accD);

    attrName = "deceleration";
    gapA->read_attribute(attrName) >> (dcA);
    gapB->read_attribute(attrName) >> (dcB);
    gapC->read_attribute(attrName) >> (dcC);
    gapD->read_attribute(attrName) >> (dcD);

    // If all values the same, set engineering gap acceleration to value otherwise to 0.
    if( (accA == accB) && (accA == accC) && (accA == accD) && (accA == dcA)
	        && (accA == dcB) && (accA == dcC) && (accA == dcD))
	    engineeringGapAxesAcceleration = accA;
    else
	    engineeringGapAxesAcceleration = 0;

    //  Set the attribute value
	attr.set_value(&engineeringGapAxesAcceleration);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringGapAcceleration
}

//--------------------------------------------------------
/**
 *	Write EngineeringGapAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringGapAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringGapAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringGapAcceleration) ENABLED START -----*/

	string attrName = "acceleration";
	Tango::DeviceAttribute devattr;
	devattr.set_name(attrName); // Set the name of attribute.
	devattr << w_val; // Add value.

    try
    {
        // Write acceleration attributes.
        gapA->write_attribute(devattr);
        gapB->write_attribute(devattr);
        gapC->write_attribute(devattr);
        gapD->write_attribute(devattr);

        // Write deceleration attributes.
        attrName = "deceleration";
        devattr.set_name(attrName); // Set the name of attribute.
        gapA->write_attribute(devattr);
        gapB->write_attribute(devattr);
        gapC->write_attribute(devattr);
        gapD->write_attribute(devattr);
    }
    catch(...)
    {
        ERROR_STREAM << "Error writing EngineeringGapAcceleration." << endl;
    }

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringGapAcceleration
}

//--------------------------------------------------------
/**
 *	Read EngineeringPhaseAcceleration attribute
 *	Description: Phase axes engineering movement average acceleration/deceleration in um/s^2.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_EngineeringPhaseAcceleration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_EngineeringPhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_EngineeringPhaseAcceleration) ENABLED START -----*/

	//	Set the attribute value
	double accA;
    double accB;
    double accC;
	double accD;
    double dcA;
    double dcB;
    double dcC;
    double dcD;

    string attrName = "acceleration";


    // Read gap axes accelerations and decelerations.
    phaseA->read_attribute(attrName) >> (accA);
    phaseB->read_attribute(attrName) >> (accB);
    phaseC->read_attribute(attrName) >> (accC);
    phaseD->read_attribute(attrName) >> (accD);

    attrName = "deceleration";
    phaseA->read_attribute(attrName) >> (dcA);
    phaseB->read_attribute(attrName) >> (dcB);
    phaseC->read_attribute(attrName) >> (dcC);
    phaseD->read_attribute(attrName) >> (dcD);

    // If all values the same, set engineering phase acceleration to value otherwise to 0.
    if( (accA == accB) && (accA == accC) && (accA == accD) && (accA == dcA)
	        && (accA == dcB) && (accA == dcC) && (accA == dcD))
	    engineeringPhaseAxesAcceleration = accA;
    else
	    engineeringPhaseAxesAcceleration = 0;

    attr.set_value(&engineeringPhaseAxesAcceleration);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_EngineeringPhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Write EngineeringPhaseAcceleration attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_EngineeringPhaseAcceleration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_EngineeringPhaseAcceleration(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_EngineeringPhaseAcceleration) ENABLED START -----*/

	string attrName = "acceleration";
    Tango::DeviceAttribute devattr;
    devattr.set_name(attrName); // Set the name of attribute.
    devattr << w_val; // Add value.

    // Write acceleration attributes.
    phaseA->write_attribute(devattr);
    phaseB->write_attribute(devattr);
    phaseC->write_attribute(devattr);
    phaseD->write_attribute(devattr);

    // Write deceleration attributes.
    attrName = "deceleration";
    devattr.set_name(attrName); // Set the name of attribute.
    phaseA->write_attribute(devattr);
    phaseB->write_attribute(devattr);
    phaseC->write_attribute(devattr);
    phaseD->write_attribute(devattr);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_EngineeringPhaseAcceleration
}

//--------------------------------------------------------
/**
 *	Read Interlock attribute
 *	Description: Indicates that interlock is in effect.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Interlock(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Interlock(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Interlock) ENABLED START -----*/

	//	Set the attribute value

	// Send command to return Digital output 5.
	send_command("IlockAct=?", *controlBoxGap);
	stringstream response(devdata_to_string());

	// If valid response.
	if (std::string::npos != response.str().find(":"))
	    response >> interlock;
	else
	    ERROR_STREAM << "Error reading interlock from gap DMC." << endl;

	// No need to read from second DMC if we are already in interlock.
	if(!interlock)
	{
	    send_command("IlockAct=?", *controlBoxPhase);
	    response.str(devdata_to_string());

	    if (std::string::npos != response.str().find(":"))
	        response >> interlock;
	    else
	        ERROR_STREAM << "Error reading interlock from phase DMC." << endl;
	}

	attr.set_value(&interlock);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Interlock
}
//--------------------------------------------------------
/**
 *	Read Coil1 attribute
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Coil1(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Coil1(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Coil1) ENABLED START -----*/
	*attr_Coil1_read = supplies[0].get_current();

	//	Set the attribute value
	attr.set_value(attr_Coil1_read);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Coil1
}

//--------------------------------------------------------
/**
 *	Write Coil1 attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Coil1(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Coil1(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Coil1) ENABLED START -----*/

	*attr_Coil1_read = w_val;
	supplies[0].set_current(w_val);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Coil1
}

//--------------------------------------------------------
/**
 *	Read Coil2 attribute
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Coil2(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Coil2(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Coil2) ENABLED START -----*/
	*attr_Coil2_read = supplies[1].get_current();

	//	Set the attribute value
	attr.set_value(attr_Coil2_read);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Coil2
}

//--------------------------------------------------------
/**
 *	Write Coil2 attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Coil2(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Coil2(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Coil2) ENABLED START -----*/

	*attr_Coil2_read = w_val;
	supplies[1].set_current(w_val);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Coil2
}

//--------------------------------------------------------
/**
 *	Read Coil3 attribute
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Coil3(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Coil3(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Coil3) ENABLED START -----*/
	*attr_Coil3_read = supplies[2].get_current();

	//	Set the attribute value
	attr.set_value(attr_Coil3_read);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Coil3
}

//--------------------------------------------------------
/**
 *	Write Coil3 attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Coil3(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Coil3(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Coil3) ENABLED START -----*/

	*attr_Coil3_read = w_val;
	supplies[2].set_current(w_val);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Coil3
}

//--------------------------------------------------------
/**
 *	Read Coil4 attribute
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_Coil4(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_Coil4(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_Coil4) ENABLED START -----*/
	*attr_Coil4_read = supplies[3].get_current();

	//	Set the attribute value
	attr.set_value(attr_Coil4_read);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_Coil4
}

//--------------------------------------------------------
/**
 *	Write Coil4 attribute values to hardware.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_Coil4(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_Coil4(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_Coil4) ENABLED START -----*/

	*attr_Coil4_read = w_val;
	supplies[3].set_current(w_val);

	/*----- PROTECTED REGION END -----*/	//	Undulator::write_Coil4
}

//--------------------------------------------------------
/**
 *	Read CorrectionEnabled attribute
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::read_CorrectionEnabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Undulator::read_CorrectionEnabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Undulator::read_CorrectionEnabled) ENABLED START -----*/

	//	Set the attribute value
	attr.set_value(attr_CorrectionEnabled_read);

	/*----- PROTECTED REGION END -----*/	//	Undulator::read_CorrectionEnabled
}

//--------------------------------------------------------
/**
 *	Write CorrectionEnabled attribute values to hardware.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar 
 */
//--------------------------------------------------------
void Undulator::write_CorrectionEnabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Undulator::write_CorrectionEnabled(Tango::Attribute &attr) entering... " << endl;
	
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	
	/*----- PROTECTED REGION ID(Undulator::write_CorrectionEnabled) ENABLED START -----*/

	if(w_val)
	{
		// Turn on the power supplies
		for (int i=0;i<4;i++)
		{
			supplies[i].on();
		}

		// Turn on compensation
		pollerThread->set_compensate(true);
	}else {
		// Turn off the power supplies
		for (int i=0;i<4;i++)
		{
			supplies[i].off();
		}

		// Turn off compensation. Function waits for the last compensation to process.
		pollerThread->set_compensate(false);
	}
	/*----- PROTECTED REGION END -----*/	//	Undulator::write_CorrectionEnabled
}


//--------------------------------------------------------
/**
 *	Method      : Undulator::UndulatorClass::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *	              for specified device.
 */
//--------------------------------------------------------
void Undulator::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Undulator::Class::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

	/*----- PROTECTED REGION END -----*/	//	Undulator::Class::add_dynamic_attributes

}



//========================================================
//	Command execution methods
//========================================================

//--------------------------------------------------------
/**
 *	Execute the StopGap command:
 *	Description: Stops gap movement.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::stop_gap()
{
	DEBUG_STREAM << "Undulator::StopGap()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::stop_gap) ENABLED START -----*/

	//	Add your own code

	// Sends command to stop gap motors.
	send_command("HX 7; ST S", *controlBoxGap);
	// Something is wrong. Alert user so he can use other ways to stop motors.
	if(devdata_to_string().compare("::") != 0)
	{
	    ERROR_STREAM << "Undulator::stop_gap()  - Error sending stop gap command!"  << endl;
	    Tango::Except::throw_exception("Stop gap command couldn't be sent to DMC.","Stop gap command couldn't be sent to DMC.","Stop gap.",Tango::ERR);
	}

	/*----- PROTECTED REGION END -----*/	//	Undulator::stop_gap

}

//--------------------------------------------------------
/**
 *	Execute the ToggleStopAll command:
 *	Description: Emergency stop all command. 
 *	             If called with the parameter set to TRUE, aborts all motion 
 *	             and inhibits all further requests for motion until the command 
 *	             is invoked again with the parameter set to FALSE.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::toggle_stop_all(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "Undulator::ToggleStopAll()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::toggle_stop_all) ENABLED START -----*/

	string command;
	// Set command based on input.
	if(argin)
	    command = "StopRq=1";
	else
	    command = "StopRq=0";

    bool error = false;

    // Sends command to stop gap motors.
    send_command(command, *controlBoxGap);
    // Something is wrong. Alert user so he can use other ways to stop motors.
    if(devdata_to_string().compare(":") != 0)
    {
	    ERROR_STREAM << "Undulator::stop_all()  - Error sending stop all gap command!"  << endl;
	    error = true;
    }
    // Sends command to stop phase motors.
    send_command(command, *controlBoxPhase);
    // Something is wrong. Alert user so he can use other ways to stop motors.
    if(devdata_to_string().compare(":") != 0)
    {
	    ERROR_STREAM << "Undulator::stop_all()  - Error sending stop all phase command!"  << endl;
	    error = true;
    }
    // If no error occurred set stop all status to desired.
    if(!error)
        stopAll = argin;
    else
        Tango::Except::throw_exception("Stop command couldn't be sent to DMC.","Stop command couldn't be sent to DMC.","Stop all command.",Tango::ERR);


	/*----- PROTECTED REGION END -----*/	//	Undulator::toggle_stop_all

}

//--------------------------------------------------------
/**
 *	Execute the DisableLimits command:
 *	Description: Disable software limits on the DMC. 
 *	             Set parameter to TRUE to disable the limits. 
 *	             To re-enable the limits invcoke command with FALSE parameter.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::disable_limits(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "Undulator::DisableLimits()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::disable_limits) ENABLED START -----*/

	if(argin)
	{
	    // Command to send to disable soft limits on DMC.
	    string limitsCommand = "FL 2147483647,2147483647,2147483647,2147483647; BL -2147483648,-2147483648,-2147483648,-2147483648";

	    send_command(limitsCommand, *controlBoxGap);

	    bool success = true;
	    // Check gap limits disabled response.
	    if(devdata_to_string().compare("::") != 0)
	    {
	        ERROR_STREAM << "Error disabling gap soft limits." << endl;
	        success = false;
	    }

	    send_command(limitsCommand, *controlBoxPhase);

	    // Check phase limits disabled response.
	    if(devdata_to_string().compare("::") != 0)
	    {
	        ERROR_STREAM << "Error disabling phase soft limits."  << endl;
	        success = false;
	    }
	    // If no error occurred set limitsDisabled to true.
	    if(success)
	        limitsDisabled = success;
	    else
	        Tango::Except::throw_exception("Disable limits command couldn't be sent to DMC.","Disable limits command couldn't be sent to DMC.","Disable limits - true",Tango::ERR);
	}
	else
	{
	    // Enable the limits.
	    set_soft_limits_phase();
	    set_soft_limits_gap();
	    limitsDisabled = false;
	}


	/*----- PROTECTED REGION END -----*/	//	Undulator::disable_limits

}

//--------------------------------------------------------
/**
 *	Execute the StopPhase command:
 *	Description: Stops phase movement.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::stop_phase()
{
	DEBUG_STREAM << "Undulator::StopPhase()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::stop_phase) ENABLED START -----*/

	// Sends command to stop gap motors.
	send_command("HX 7; ST S", *controlBoxPhase);
    // Something is wrong. Alert user so he can use other ways to stop motors.
    if(devdata_to_string().compare("::") != 0)
    {
        ERROR_STREAM << "Undulator::stop_phase()  - Error sending stop phase command!"  << endl;
        Tango::Except::throw_exception("Stop phase command couldn't be sent to DMC.","Stop phase command couldn't be sent to DMC.","Stop phase.",Tango::ERR);
    }

	/*----- PROTECTED REGION END -----*/	//	Undulator::stop_phase

}

//--------------------------------------------------------
/**
 *	Execute the CalibrateGap command:
 *	Description: Calculates gap axes offsets using given gap and center and reading positions from encoders.
 *
 *	@param argin Current gap and center.
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::calibrate_gap(const Tango::DevVarDoubleArray *argin)
{
	DEBUG_STREAM << "Undulator::CalibrateGap()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::calibrate_gap) ENABLED START -----*/

    double encoderA, encoderB, encoderC, encoderD;
    string delimiter;

    // Read aux encoder positions.
    send_command("TDA;TDB;TDC;TDD", *controlBoxGap);
    stringstream response(devdata_to_string());

    response >> encoderA;
    response >> delimiter;
    response >> encoderB;
    response >> delimiter;
    response >> encoderC;
    response >> delimiter;
    response >> encoderD;

    // Update new offsets.

    offsets[2] = -(*argin)[0]/2 + (*argin)[1] - convert_to_micrometers(encoderC, positionRatioPhase);     // -G/2+center = TDC + offset[2]
    offsets[3] = -(*argin)[0]/2 + (*argin)[1] - convert_to_micrometers(encoderD, positionRatioPhase);     // -G/2+center = TDD + offset[3]

    offsets[0] = (*argin)[0]/2 + (*argin)[1] - convert_to_micrometers(encoderA, positionRatioPhase) - convert_to_micrometers(encoderC, positionRatioPhase); // G/2+center = TDA + TDC + Offsets[0]
    offsets[1] = (*argin)[0]/2 + (*argin)[1] - convert_to_micrometers(encoderB, positionRatioPhase) - convert_to_micrometers(encoderD, positionRatioPhase); // G/2+center = TDB + TDC + Offsets[1]

    string attrName = "offset";
    Tango::DeviceAttribute devattr;
    devattr.set_name(attrName); // Set the name of attribute.

    // Write offset attributes.
    devattr << offsets[0]; // Add value.
    gapA->write_attribute(devattr);
    devattr << offsets[1]; // Add value.
    gapB->write_attribute(devattr);
    devattr << offsets[2]; // Add value.
    gapC->write_attribute(devattr);
    devattr << offsets[3]; // Add value.
    gapD->write_attribute(devattr);


	/*----- PROTECTED REGION END -----*/	//	Undulator::calibrate_gap

}

//--------------------------------------------------------
/**
 *	Execute the CalibratePhase command:
 *	Description: Calculates phase axes offsets on zero phase.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::calibrate_phase()
{
	DEBUG_STREAM << "Undulator::CalibratePhase()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::calibrate_phase) ENABLED START -----*/

	string attrName = "position";
	double posA,posB,posC,posD;

	// Read motor positions.
    phaseA->read_attribute(attrName) >> posA;
    phaseB->read_attribute(attrName) >> posB;
    phaseC->read_attribute(attrName) >> posC;
    phaseD->read_attribute(attrName) >> posD;

    // Offsets are equal to - current positions since we are a 0.
    // Compensate for current offsets.

    // Update new offsets.
    offsets[4] += -posA;
    offsets[5] += -posB;
    offsets[6] += -posC;
    offsets[7] += -posD;

    attrName = "offset";
    Tango::DeviceAttribute devattr;
    devattr.set_name(attrName); // Set the name of attribute.

    // Write offset attributes.
    devattr << offsets[4]; // Add value.
    phaseA->write_attribute(devattr);
    devattr << offsets[5]; // Add value.
    phaseB->write_attribute(devattr);
    devattr << offsets[6]; // Add value.
    phaseC->write_attribute(devattr);
    devattr << offsets[7]; // Add value.
    phaseD->write_attribute(devattr);


	/*----- PROTECTED REGION END -----*/	//	Undulator::calibrate_phase

}

//--------------------------------------------------------
/**
 *	Execute the LoadCorrectionData command:
 *	Description: Loads the interpolation data for the coil correction from a file.
 *	              
 *	             Load can not be called while running. The data could be shared with the thread without locking.
 *
 *	@param argin filename
 *	@returns 
 */
//--------------------------------------------------------
void Undulator::load_correction_data(Tango::DevString argin)
{
	DEBUG_STREAM << "Undulator::LoadCorrectionData()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Undulator::load_correction_data) ENABLED START -----*/

	ifstream inFile(argin);

	if (!inFile.good())
		Tango::Except::throw_exception("Invalid filename provided.","The file-name in the argument could not be opened.",__PRETTY_FUNCTION__);

	int n = count(istreambuf_iterator<char>(inFile), istreambuf_iterator<char>(), '\n');
	if (n<=1)
		Tango::Except::throw_exception("The file does not contain any data.","",__PRETTY_FUNCTION__);

	data.clear();
	data.reserve(n);

	inFile.seekg(0,ios_base::beg);

	string line;
	// read the first header line
	std::getline(inFile,line);

	// Load the data
	DataItem item;
	while (true)
	{
		inFile >> item;
		if (!inFile.good()) break;

		cout << item;

		item.normalize();

		data.push_back(item);
	}

	/*----- PROTECTED REGION END -----*/	//	Undulator::load_correction_data

}


	/*----- PROTECTED REGION ID(Undulator::namespace_ending) ENABLED START -----*/

/**
 * Extracts devdata to string.
 *
 * @return Tango::DevData DMC response in string format.
 */
string Undulator::devdata_to_string()
{
    string temp;
    devdata >> temp;
    return temp;
}

/**
 * Sends low level execute command through control box to DMC.
 * Updates devdata on undulator with DMC response.
 *
 * @param command Command sent to DMC.
 * @param controlBox Reference to receiver controlbox.
 */
void Undulator::send_command(string command, Tango::DeviceProxy &controlBox )
{
    // Send command through controlbox to DMC.
    devdata << command;
    devdata = controlBox.command_inout("ExecLowLevelCmd", devdata);
}

/**
 * Calculates final destinations of phase axes depending on desired phase.
 *
 * @param destinations[] Destinations array to fill.
 */
void Undulator::calculate_motor_destinations(double destinations[])
{
    switch(desiredPhase)
    {
        // Phase A - X1 and X4 fixed, X2 and X3 move parallel to desired offset.
        case 0:
            destinations[1] = desiredOffset;
            destinations[2] = desiredOffset;
            break;
        // Phase B - X2 and X3 fixed, X1 and X4 move parallel to desired offset.
        case 1:
            destinations[0] = desiredOffset;
            destinations[3] = desiredOffset;
            break;
        // Phase C - X1 and X4 fixed, X2 and X3 move antiparallel to desired offset.
        case 2:
            destinations[1] = desiredOffset;
            destinations[2] = -desiredOffset;
            break;
        // Phase D - X2 and X3 fixed, X1 and X4 move antiparallel to desired offset.
        case 3:
            destinations[0] = desiredOffset;
            destinations[3] = -desiredOffset;
            break;
        // Nothing to change leave all at phase center.
        default:
            break;
    }
}

/**
 *  Gets offsets from all axes and stores them in offsets array.
 */
void Undulator::get_offsets()
{
    // Attribute name.
    string attr = "offset";
    Tango::DeviceAttribute devattr; //!< Device attribute

    // Read all 8 offsets and put them in array.

    devattr = gapA->read_attribute(attr);
    devattr >> offsets[0];
    devattr = gapB->read_attribute(attr);
    devattr >> offsets[1];
    devattr = gapC->read_attribute(attr);
    devattr >> offsets[2];
    devattr = gapD->read_attribute(attr);
    devattr >> offsets[3];

    devattr = phaseA->read_attribute(attr);
    devattr >> offsets[4];
    devattr = phaseB->read_attribute(attr);
    devattr >> offsets[5];
    devattr = phaseC->read_attribute(attr);
    devattr >> offsets[6];
    devattr = phaseD->read_attribute(attr);
    devattr >> offsets[7];
}
/**
 * Takes user unit and converts it to counts.
 *
 * @param number User unit to convert to counts.
 * @param ratio Ratio to use for conversion.
 * @return Converted user units in counts.
 */
double Undulator::convert_to_counts(double number, double ratio)
{
    return number/ratio;
}

/**
 * Calculates software limits for gap and sets them on DMC.
 */
void Undulator::set_soft_limits_gap()
{
    // Calculate current limits depending on center, taper and min/max gap.
    double switches[8];
    switches[0] = convert_to_counts(desiredCenter - desiredTaper/4 + maxGap/2 - offsets[0], positionRatioGap); // FLZ1
    switches[4] = convert_to_counts(desiredCenter - desiredTaper/4 + minGap/2 - offsets[0], positionRatioGap); // BLZ1

    switches[1] = convert_to_counts(desiredCenter + desiredTaper/4 + maxGap/2 - offsets[1], positionRatioGap); // FLZ2
    switches[5] = convert_to_counts(desiredCenter + desiredTaper/4 + minGap/2 - offsets[1], positionRatioGap); // BLZ2

    switches[2] = convert_to_counts(desiredCenter + desiredTaper/4 - minGap/2 - offsets[2], positionRatioGap); // FLZ3
    switches[6] = convert_to_counts(desiredCenter + desiredTaper/4 - maxGap/2 - offsets[2], positionRatioGap); // BLZ3

    switches[3] = convert_to_counts(desiredCenter - desiredTaper/4 - minGap/2 - offsets[3], positionRatioGap); // FLZ4
    switches[7] = convert_to_counts(desiredCenter - desiredTaper/4 - maxGap/2 - offsets[3], positionRatioGap); // BLZ4

    stringstream cmd;

    // Add forward limit command.
    cmd << "FL ";
    for(int i = 0; i < 4; i++)
    {
        cmd << fixed << switches[i];

        if (i != 3)
            cmd << ",";
    }

    // Add backward limit command.
    cmd << ";BL ";
    for(int i = 4; i < 8; i++)
    {
        cmd << fixed << switches[i];

        if (i != 7)
            cmd << ",";
    }
    // Send to gap DMC.
    send_command(cmd.str(), *controlBoxGap);

    // Check for errors.
    if(devdata_to_string().compare("::") != 0)
    {
        ERROR_STREAM << "Gap axes soft limit update failed." << endl;
        Tango::Except::throw_exception("Error in setting soft limits on DMC.","Error in setting soft limits on DMC.","Set soft limits gap.",Tango::ERR);

    }
}
/**
 * Calculates software limits for phase and sets them on DMC.
 */
void Undulator::set_soft_limits_phase()
{
    // Calculate current limits depending on max operator offset.
    double switches[8];

    // Calculate limits and apply offsets.
    for(int i = 0; i < 4; i++)
    {
    switches[i] = phaseCenter + maxOpPhase - offsets[i+4];
    switches[i+4] = phaseCenter - maxOpPhase - offsets[i+4];
    }

    stringstream cmd;

    // Add forward limits command.
    cmd << "FL ";

    for(int i = 0; i < 4; i++)
    {
        cmd << fixed << convert_to_counts(switches[i], positionRatioPhase);

        if(i != 3)
            cmd << ",";
    }

    // Add backward limit command.
    cmd << ";BL ";

    for (int i = 4; i < 8; i++)
    {
        cmd << fixed << convert_to_counts(switches[i], positionRatioPhase);

        if(i != 7)
            cmd << ",";
    }

    // Send command to phase DMC.
    send_command(cmd.str(), *controlBoxPhase);

    // Check for errors.
    if(devdata_to_string().compare("::") != 0)
    {
        ERROR_STREAM << "Phase axes soft limit update failed." << endl;
        Tango::Except::throw_exception("Error in setting soft limits on DMC.","Error in setting soft limits on DMC.","Set soft limits phase.", Tango::ERR);
    }
}

/**
 * Converts counts to micrometers using given ratio.
 *
 * @param value Value to convert to micrometers.
 * @param ratio Ratio to use for conversion.
 * @return Converted value.
 */
double Undulator::convert_to_micrometers(double value, double ratio)
{
    return value * ratio;
}

/**
 * Sends all required parameters for gap movement and starts it on DMC.
 */
void Undulator::start_gap()
{
    // Deny move if in engineering mode.
    if(engineeringLock)
    {
        ERROR_STREAM << "Engineering lock is enabled. Movement denied." << endl;

        Tango::Except::throw_exception("Engineering lock enabled.",
                    "Move gap not permitted under engineering lock.","Move gap command.",Tango::ERR);
        return;
    }
    // Create command to send. Send center,gap and taper parameters.

    stringstream cmd;

    // Offsets update part.
    for(int i = 0; i < 4; i++)
    {
        cmd << "Offsets[" << i << "]=" << fixed << convert_to_counts(offsets[i], positionRatioGap) << ";";
    }
    // Rest of command.
    cmd << "GapOfst="
        << fixed << convert_to_counts(desiredCenter, positionRatioGap)
        << ";Gap="
        << fixed << convert_to_counts(desiredGap, positionRatioGap)
        << ";Taper="
        << fixed << convert_to_counts(desiredTaper, positionRatioGap)
        << ";TprSpd="
        << fixed << convert_to_counts(taperSpeed, positionRatioGap)
        << ";GapSpd="
        << fixed << convert_to_counts(gapSpeed, positionRatioGap)
        << ";GapAcc="
        << fixed << convert_to_counts(gapAcc ,positionRatioGap)
        << ";TprAcc="
        << fixed << convert_to_counts(taperAcc, positionRatioGap)
        << ";XQ#GAP,7"; // Execute movement on 7th thread.

    // Send command.
    send_command(cmd.str(), *controlBoxGap);

    // If we get positive confirmation of all commands.
    if (devdata_to_string().compare("::::::::::::") == 0)
    {
        gapMoving = true;
    }
    else
    {
        // Show error in log.
        ERROR_STREAM << "Error in start gap procedure." << endl;
        Tango::Except::throw_exception("Error starting gap movement.",
                "Start gap movement command failed.","Start gap movement.",Tango::ERR);
    }
}

/**
 * Calculates final motor positions, sends required parameters
 * and starts phase movement on DMC.
 */
void Undulator::start_phase()
{
    // If lock or operator wants too much offset we deny.
    if(engineeringLock)
    {
        ERROR_STREAM << "Engineering lock enabled. Movement denied." << endl;
        Tango::Except::throw_exception("Engineering lock or out of bounds max operator phase offset desired.",
                            "Move phase not permitted under current conditions","Start move phase command.",Tango::WARN);
        return;
    }

    // Calculate destinations according to desired phase.
    double destinations[4] = {0,0,0,0};
    calculate_motor_destinations(destinations);

    // Create command to send.
    stringstream cmd;

    // Offsets update part.

    for(int i = 0; i < 4; i++)
    {
        cmd << "Offsets[" << i << "]=" << fixed << convert_to_counts(offsets[i+4], positionRatioPhase) << ";";
    }
    // Rest of command.
    cmd << "PhMdRq="
        << desiredPhase
        << ";PhDest[0]="
        << fixed << convert_to_counts(destinations[0], positionRatioPhase)
        << ";PhDest[1]="
        << fixed << convert_to_counts(destinations[1], positionRatioPhase)
        << ";PhDest[2]="
        << fixed << convert_to_counts(destinations[2], positionRatioPhase)
        << ";PhDest[3]="
        << fixed << convert_to_counts(destinations[3], positionRatioPhase)
        << ";PhSpd="
        << fixed << convert_to_counts(phaseSpeed, positionRatioPhase)
        << ";PhAcc="
        << fixed << convert_to_counts(phaseAcc, positionRatioPhase)
        << ";XQ#PHASE,7";

    // Send command.
    send_command(cmd.str(), *controlBoxPhase);

    // If we get positive confirmation of all commands.
    if (devdata_to_string().compare("::::::::::::") == 0)
    {
        phaseMoving = true;
    }
    else
    {
        // Show error in log.
        ERROR_STREAM << "Error in start phase procedure."  << endl;
        Tango::Except::throw_exception("Error starting phase movement.",
                        "Start phase movement command failed.","Start phase movement.",Tango::ERR);
    }

}



	/*----- PROTECTED REGION END -----*/	//	Undulator::namespace_ending
} //	namespace
