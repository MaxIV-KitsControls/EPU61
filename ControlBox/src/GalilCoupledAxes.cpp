static const char *RcsId = "$Header: /usr/local/CVS/DeviceServer/Generic/Motorisation/ControlBoxV2/src/GalilCoupledAxes.cpp,v 1.6 2011/07/15 09:47:42 buteau Exp $";
//+=============================================================================
//
// file :         GalilCoupledAxes.cpp
//
// description :  C++ source for the GalilCoupledAxes and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                GalilCoupledAxes are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: buteau $
//
// $Revision: 1.6 $
//
// $Log: GalilCoupledAxes.cpp,v $
// Revision 1.6  2011/07/15 09:47:42  buteau
// MANTIS 19368
//
// Revision 1.5  2011/07/15 09:40:53  buteau
// MANTIS 19368
//
// Revision 1.4  2011/05/19 10:52:44  coquet
// some include path updated
// changes yat dependency order
//
// Revision 1.3  2010/03/26 09:17:39  maven
// "Migration_Tango7_Part2"
//
// Revision 1.2  2007/11/16 10:36:32  coquet
// minor change (m_properties_missing initialisation)
//
// Revision 1.1  2007/11/16 09:39:31  leclercq
// no message
//
// Revision 1.1  2007/11/15 16:15:22  coquet
// added Coupled Axes support
// handeles internally coupled axes, device controls only the master position
// example : the detector table of swing with 2 synchronised motors
// the coupling is provided in the micro-code in the controlbox
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State     |  dev_state()
//  Status    |  dev_status()
//  Stop      |  stop()
//  Forward   |  forward()
//  Backward  |  backward()
//
//===================================================================


#include <tango.h>
#include <GalilCoupledAxes.h>
#include <GalilCoupledAxesClass.h>
#include <PogoHelper.h>

namespace GalilCoupledAxes_ns
{

//+----------------------------------------------------------------------------
//
// method : 		GalilCoupledAxes::GalilCoupledAxes(string &s)
// 
// description : 	constructor for simulated GalilCoupledAxes
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
GalilCoupledAxes::GalilCoupledAxes(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

GalilCoupledAxes::GalilCoupledAxes(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
	init_device();
}

GalilCoupledAxes::GalilCoupledAxes(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		GalilCoupledAxes::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void GalilCoupledAxes::delete_device()
{
	//	Delete device's allocated object
	DELETE_SCALAR_ATTRIBUTE(attr_position_read);
	DELETE_SCALAR_ATTRIBUTE(attr_forwardLimitSwitch_read);
	DELETE_SCALAR_ATTRIBUTE(attr_backwardLimitSwitch_read);

  //- release the GalilCoupledAxes object
  if (this->m_coupled_axes)
  {
    delete this->m_coupled_axes;
    this->m_coupled_axes = 0;
  }
}

//+----------------------------------------------------------------------------
//
// method : 		GalilCoupledAxes::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void GalilCoupledAxes::init_device()
{
	INFO_STREAM << "GalilCoupledAxes::GalilCoupledAxes() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
		this->m_status_str = "initializing device...";
	this->m_init_device_done = false;
  this->m_coupled_axes = 0;
  m_properties_missing = false;

	// create read attributes
	CREATE_SCALAR_ATTRIBUTE(attr_position_read);
	CREATE_SCALAR_ATTRIBUTE(attr_forwardLimitSwitch_read);
	CREATE_SCALAR_ATTRIBUTE(attr_backwardLimitSwitch_read);

	get_device_property();
  if (this->m_properties_missing)
  {
    TangoSys_OMemStream oms;
	  oms << "One (or more) required properties is missing "
        << "[device initialization failed]" 
        << std::ends;
    ERROR_STREAM << oms.str() << std::endl;
    this->m_status_str = oms.str();
		this->m_init_device_done = false;
    this->set_state(Tango::FAULT);
    return;
  }
  try
  {
    //- instanciate the CoupledAxis object
    this->m_coupled_axes = new galil::CoupledAxes();
    if (this->m_coupled_axes == 0)
      throw std::bad_alloc();
  }
  catch (std::bad_alloc&)
  {
  	ERROR_STREAM << "device initialization failed [OUT OF MEMORY]" << std::endl;
    this->m_init_device_done = false;
    this->m_status_str = "device initialization failed [OUT OF MEMORY]";
    this->set_state(Tango::FAULT);
    return;
  }
  catch (...)
  {
    ERROR_STREAM << "initialization failed [unknown exception caught]" << std::endl;
    this->m_status_str = "device initialization failed [unknown exception caught]";
    this->m_init_device_done = false;
    this->set_state(Tango::FAULT);
    return;
  }

  try
  {
    //- instanciate the CoupledAxis Config object
    galil::CoupledAxes::Config coupled_axes_cfg;
    coupled_axes_cfg.master = galil::Axis::string_to_axis_id(master);
    coupled_axes_cfg.host_device = this;
    this->m_coupled_axes->configure(coupled_axes_cfg);
  }
  catch (Tango::DevFailed& df)
  {
  	ERROR_STREAM << df << std::endl;
    this->m_init_device_done = false;
    this->m_status_str = "GalilCoupledAxes configuration failed";
    this->set_state(Tango::FAULT);
    return;
  }
  catch (...)
  {
    ERROR_STREAM << "GalilCoupledAxes configuration failed [unknown exception caught]" << std::endl;
    this->m_status_str = "GalilCoupledAxes configuration failed [unknown exception caught]";
    this->m_init_device_done = false;
    this->set_state(Tango::FAULT);
    return;
  }

	this->m_init_device_done = true;

}


//+----------------------------------------------------------------------------
//
// method : 		GalilCoupledAxes::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void GalilCoupledAxes::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Master"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	GalilCoupledAxesClass	*ds_class =
		(static_cast<GalilCoupledAxesClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize Master from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  master;
	//	Try to initialize Master from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  master;
	//	And try to extract Master value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  master;



	//	End of Automatic code generation
	//------------------------------------------------------------------
  Tango::DbData data_put;
  if (dev_prop[0].is_empty() || master.find("must be defined") != std::string::npos)
	{
		m_properties_missing = true;
		Tango::DbDatum	property("Master");
		property << "must be defined - select the master axis in [A..H]";
		data_put.push_back(property);
    ERROR_STREAM << "undefined critical property <Master>" << std::endl;
	}
	if (! data_put.empty())
		get_db_device()->put_property(data_put);

}
//+----------------------------------------------------------------------------
//
// method : 		GalilCoupledAxes::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void GalilCoupledAxes::always_executed_hook()
{
	
}
//+----------------------------------------------------------------------------
//
// method : 		GalilCoupledAxes::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void GalilCoupledAxes::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "GalilCoupledAxes::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		GalilCoupledAxes::read_forwardLimitSwitch
// 
// description : 	Extract real attribute values for forwardLimitSwitch acquisition result.
//
//-----------------------------------------------------------------------------
void GalilCoupledAxes::read_forwardLimitSwitch(Tango::Attribute &attr)
{
	DEBUG_STREAM << "GalilCoupledAxes::read_forwardLimitSwitch(Tango::Attribute &attr) entering... "<< endl;

	*attr_forwardLimitSwitch_read = this->m_coupled_axes->forward_limit_switch_detected();
  attr.set_value(attr_forwardLimitSwitch_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilCoupledAxes::read_backwardLimitSwitch
// 
// description : 	Extract real attribute values for backwardLimitSwitch acquisition result.
//
//-----------------------------------------------------------------------------
void GalilCoupledAxes::read_backwardLimitSwitch(Tango::Attribute &attr)
{
	DEBUG_STREAM << "GalilCoupledAxes::read_backwardLimitSwitch(Tango::Attribute &attr) entering... "<< endl;

	*attr_backwardLimitSwitch_read = this->m_coupled_axes->backward_limit_switch_detected();
  attr.set_value(attr_backwardLimitSwitch_read);
}


//+----------------------------------------------------------------------------
//
// method : 		GalilCoupledAxes::read_position
// 
// description : 	Extract real attribute values for position acquisition result.
//
//-----------------------------------------------------------------------------
void GalilCoupledAxes::read_position(Tango::Attribute &attr)
{
	DEBUG_STREAM << "GalilCoupledAxes::read_position(Tango::Attribute &attr) entering... "<< endl;
  *attr_position_read = this->m_coupled_axes->position();

  attr.set_value(attr_position_read);
}

//+----------------------------------------------------------------------------
//
// method : 		GalilCoupledAxes::write_position
// 
// description : 	Write position attribute values to hardware.
//
//-----------------------------------------------------------------------------
void GalilCoupledAxes::write_position(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "GalilCoupledAxes::write_position(Tango::WAttribute &attr) entering... "<< endl;

  attr.get_write_value(attr_position_write);

  this->m_coupled_axes->position(attr_position_write);
}


//+------------------------------------------------------------------
/**
 *	method:	GalilCoupledAxes::stop
 *
 *	description:	method to execute "Stop"
 *	stops the movement
 *
 *
 */
//+------------------------------------------------------------------
void GalilCoupledAxes::stop()
{
	DEBUG_STREAM << "GalilCoupledAxes::stop(): entering... !" << endl;

	//	Add your own code to control device here
  this->m_coupled_axes->stop();

}

//+------------------------------------------------------------------
/**
 *	method:	GalilCoupledAxes::forward
 *
 *	description:	method to execute "Forward"
 *	initiates a jog forward
 *	continuous forward movement, stopped with Stop command
 *
 *
 */
//+------------------------------------------------------------------
void GalilCoupledAxes::forward()
{
	DEBUG_STREAM << "GalilCoupledAxes::forward(): entering... !" << endl;

	//	Add your own code to control device here
  this->m_coupled_axes->forward();

}

//+------------------------------------------------------------------
/**
 *	method:	GalilCoupledAxes::backward
 *
 *	description:	method to execute "Backward"
 *	initiates a jog backward
 *	continuous backward movement, stopped with Stop command
 *
 *
 */
//+------------------------------------------------------------------
void GalilCoupledAxes::backward()
{
	DEBUG_STREAM << "GalilCoupledAxes::backward(): entering... !" << endl;

	//	Add your own code to control device here
  this->m_coupled_axes->backward();

}

//+------------------------------------------------------------------
/**
 *	method:	GalilCoupledAxes::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState GalilCoupledAxes::dev_state()
{
	DEBUG_STREAM << "GalilCoupledAxes::dev_state(): entering... !" << endl;

	//	Add your own code to control device here
	//- is device properly initialized?
	if (! m_init_device_done ||  m_properties_missing)
  {
		this->set_state(Tango::FAULT);
    return Tango::FAULT;
	}

  galil::AxisState coupled_axes_state = this->m_coupled_axes->state();

  switch (coupled_axes_state)
  {
    case galil::AXIS_OFF:
	    this->set_state(Tango::OFF);
      return Tango::OFF;
      break;
    case galil::AXIS_MOVING:
	    this->set_state(Tango::MOVING);
      return Tango::MOVING;
      break;
    case galil::AXIS_STANDBY:
	    this->set_state(Tango::STANDBY);
      return Tango::STANDBY;
      break;
    case galil::AXIS_ALARM:
	    this->set_state(Tango::ALARM);
      return Tango::ALARM;
      break;
    case galil::AXIS_ERROR:
	    this->set_state(Tango::FAULT);
      return Tango::FAULT;
      break;
    case galil::AXIS_CRTL_DISABLED:
	    this->set_state(Tango::DISABLE);
      return Tango::DISABLE;
      break;
    default:
      break;
  }

  this->set_state(Tango::UNKNOWN);

  return Tango::UNKNOWN;
}

//+------------------------------------------------------------------
/**
 *	method:	GalilCoupledAxes::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status description
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString GalilCoupledAxes::dev_status()
{
	Tango::ConstDevString	argout = DeviceImpl::dev_status();
	DEBUG_STREAM << "GalilCoupledAxes::dev_status(): entering... !" << endl;

	//	Add your own code to control device here
	if ( this->m_properties_missing ) 
	{
		return this->m_status_str.c_str();
	}

	if (! this->m_init_device_done )
	{
    return m_status_str.c_str();
	}
  // get current status
  galil::CoupledAxesStatus cas;
  this->m_coupled_axes->status(cas);

  this->m_status_str = "Master Axis status : \n" +
                       cas.master_status.status  +
											 "\nCoupled Axes Status :\n"+
											 cas.coupled_axes_status ;

  return m_status_str.c_str();
	return argout;
}

}	//	namespace
